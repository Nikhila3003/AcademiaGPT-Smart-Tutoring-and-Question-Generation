page_content="Hello, this is Spencer Lyon and in this video we'll be talking about how we can access the United States Bureau of Labor Statistics data using their own API. Before watching this video,atching this video, you should have seen our previous video on what an API is and its main structure and usage. The goals for this video will be to understand how we can register for an API key from tor an API key from the BLS in order to have increased access to their data. We will then write the Python code that can communicate with or make requests against the BLS API. And finally we'll use thiinally we'll use this Python code to construct a data set filled with unemployment statistics or indicators as reported by the BLS. Now the Bureau of Labor Statistics collects data on employment station employment statistics for the United States. They make this data publicly available via their API. The data is available without the need for an API key, however, if we are able to provide an APIe to provide an API key, we can get additional information in our response. This is what we're going to do here today. The first step then will be to register for an API key. What we'll do is we willwe'll do is we will open the landing page for the BLS API documentation. And once they're well identified where we can look for how to give an API key. Once we've done that, we'll receive our API keyreceive our API key of the email and we'll store it some more safe. We need to remind you that we should treat this API key like a password. Because in the world of APIs, the key really is a password.eally is a password. It's something unique and secret for you that can identify you as a person and a user of their system. If you, if this gets out, other people can pretend to be you as they interacyou as they interact with those services which could have unintended consequences. So let's look right now at this documentation page on their website. When we go there, we see the following. We're ge following. We're greeted with a page that looks like this. We'll see here that the there's some information on the data and it says it's currently available in two versions. Version two requires region two requires registration to allow users to access data more frequently. We'll click this registration link and we'll be taken to this page here. Now in order to register, we have to specify whichave to specify which organization we are affiliated with, what our email address is, and then respond to the capture that is put here. We can read and review the terms of service, check that we agreedcheck that we agreed to them and submit a registration. We should be able to then get an email very quickly with our API key. And again, once we have that, we'll store it somewhere safe and we'll usesafe and we'll use it later on in this video. Now, once we know how we can authenticate with the API, we need to figure out how to build the request that we'd like. You recall from our previous videom our previous video on an API that a request has the following components. We need to have an endpoint or a URL for where our request should be sent. We need to know what type we should associate witshould associate with our request. We need to know if there are any necessary query parameters that should be sent to identify what we would like to do at that endpoint. We may have a payload that wee a payload that we send that gives additional information about what the specifics of our request entail. Headers can provide some context around who we are and why we're making the request. And finahe request. And finally, we need to know how to use our API key to authenticate ourselves. We're going to work through how we can identify each of these points from the BLS API documentation. So firstumentation. So first, let's work on an endpoint. We're going to go again to the API documentation page. And our goal here is to find where we can access data. So what we'll do is we'll go back to thise'll go back to this getting started page. And then this link right here, the using BLS API signatures, we'll take us to a page that describes all the different endpoints and other documentation for tdocumentation for their API. What we're going to be interested in is being able to gather data on multiple series. So what we're going to be looking at is actually this third option called one or moron called one or more series with optional parameters. We'll go ahead and we'll click that and we created with the documentation. So it tells us that we can use this format or this endpoint to get datendpoint to get data for one or more time series for a time frame of up to 20 years. We'll also be able to request different types of calculations, averages and catalog data. We're not going to be loe not going to be looking at these three things, but the catalog data will be meaningful. And the reason for it is by default, the BLS uses these series ID to identify a series and they look like whatthey look like what I've highlighted here. They're quite difficult to understand and they don't have much human meaning. The catalog on the other hand will have a lot of information that is easier foon that is easier for a person understand. We can get if it's if the data. Behind the series ID belongs to a particular geography, it will tell us that here. It'll tell us the seasonality which surveyonality which survey the data comes from. What the human readable name for the series is. And so this catalog will be very helpful in helping us understand what data we're actually getting and how wegetting and how we can use it. So it says here that in order to get these optional parameters, users must have a registration key. So in order to get this catalog data, we need an API key and that'sAPI key and that's why we went through the registration step before. And so for further down in the documentation, we see that users have to include at least one series ID. The start year and the endart year and the end year in the body or payload of the request. If we have multiple series IDs, we need to separate them with a comma. So again, our goal here is to find the end point or the URL we'loint or the URL we'll be using. And here we see that the URL is the following. The HTTPS scheme, we're going to be accessing the host api.bls.gov. The path is highlighted here, public api slash v2 slalic api slash v2 slash time series slash data. This is the endpoint that we'll be using for accessing our data. So let's go back to the documentation page and try to identify both the request type andthe request type and the query parameters. So when we go here, we see just above the URL, the documentation says that HTTP type is post. So here, even though we're not requesting the BLS save our datahe BLS save our data or store it, we still are asked to send a request using the post type. Now the reason for this is because technically a get request shouldn't have a JSON payload or body. And so tad or body. And so the most common type of request that allows for a payload is the post request. So in this case, we're kind of bending the convention of when a post should be used. And we're doing sd. And we're doing so in order to attach a payload to our request. So we'll back up a little bit and we're trying we just identify that we're doing a post request and looking here at the URL. We're acat the URL. We're actually not going to be using any query parameters. There is a format of the API that allows us to query parameters. But you'll see here that things like the registration key or catistration key or catalog can be passed down in the payload. Here it shows up again registration key catalog. And because the documentation specified that we must include these things in the body of thgs in the body of the request, we're going to opt for putting all that information in the body. And not having to worry about putting some things in query parameters appear and other things as part ofer things as part of the body. We're going to attach no query parameters, so we'll use this URL as is and we'll put all the other information into the body. So here's kind of a summary of what we justmary of what we just walked through. So now if we look at that data documentation, we'll see that the payload or the body has a structure that looks like this. We were told that series ID start year aries ID start year and end year must be passed and they have the following form. Notice here that this is kind of like a Python dictionary. We're going to pass in a JSON payload. The key series ID wilhe key series ID will map to a list or a ray of series IDs. We can have a start year mapping to a year and this would be a four digit number or a string representing a four digit number. And then theumber. And then the end year would be the same. All the other options down here, these four are optional. We are going to only worry about setting catalog equal true so that we can get the informationget the information about what each series ID represents. We're going to skip these three and then finally we will pass our API key or registration key at the bottom. We're going to be able to obtainto be able to obtain a registration key. Then you'll only have to pass these top three as the catalog feature is only enabled for users that have an API key. And don't worry at the very end, we'll provery end, we'll provide a downloadable file with all the catalog information. So if you are unable to get a registration key, you'll still be able to proceed with further analysis. But it's good prac. But it's good practice to work through all these steps if possible. Now, as we look through the documentation again, there's no notion of required HTTP headers. So we won't include any except we wilde any except we will accept for the content type header because we're passing in our in the body or payload of our request that JSON object we just saw. We're going to set the content type header totent type header to be application slash JSON. This is just going to tell the BLS that we do have a payload and that its contents should be interpreted as JSON. And we'll just kind of remind all the vof remind all the viewers that the JSON stands for JavaScript object notation and is kind of the web or API way to talk about it. To talk about what we refer to as a dictionary in Python. Okay, the fPython. Okay, the final component in the in using an API is authentication. We need to be able to identify who we are and for that we'll use our API key. We've already talked about where this will got where this will go for the BLS API and what we need to do is set the registration key field on the payload or the body of our request. So let's summarize. What we'll be doing is making a post requesmaking a post request to the following URL. This is the endpoint that we're accessing. We don't have any query parameters. So there's no question mark and parameters passed in the URL. In the body ofURL. In the body of our request, we will be passing series ID. Start year, end year, catalog and registration key. And finally, we will set the content type to application JSON in the header of our rethe header of our request. This will again let the BLS know that we're passing a payload or body with JSON data. Okay, now that we've done our homework and we understand what we need to do. Let's talked to do. Let's talk about how we do it. In order to make our HTTP requests or API requests, we're going to be using the request library in Python. We're also going to be needing to convert things too convert things to and from JSON. So we'll import that. We'll also import pandas as PD like usual and then finally, so that we have clean documented code. We're going to import a few of these helpersfew of these helpers from the typing library. These aren't ever going to be called by us. They're just going to be attached to our function parameters. And you'll see this below. So execute the cell ao execute the cell and import the necessary packages. Now, we need to make a request and we're going to use a Python function to do that. And we're going to study what this request does. So here's thedoes. So here's the code that we've written for interacting with the BLS API. So we need to, we have a function named request for series that takes four parameters. These four are series IDs start yeseries IDs start year and year in API key and they map. closely to the payload parameters series ID start year and year and registration key. So the series ID, you see here that this syntax where wehis syntax where we have a variable name, colon, a type is a way for us to write down the type that is expected in this parameter. So that when people go to use our function, they see that this is thesee that this is the expected type and it provides a little bit more insight into how this should be used. So here we're saying that the series ID should be specified as a list of strings. Both startstrings. Both start year and end year have the type union into comma string. Now what union means is it could be any of the types contained within this square brackets. So start year, it is appropriatar, it is appropriate to pass an integer or a string representing an integer, same for end year. Finally, the API key has type optional string optional is Python's way of saying the value can either be value can either be the none value or it can be of type whatever's in the square brackets. So here we're saying you either need to either need to pass a string or none. We'll have a default value hee a default value here of none. We then wrote some documentation strings that describe what these things are and what they do. And we have here a list of all the parameters we're going to describe whaoing to describe what the responses are. And in this case, we will have a list of response objects that come from the request package. And then finally there are some notes that we've written for ours've written for ourselves so that while we're member why we made certain decisions in the code. Let's jump to the code and then you can look back on these notes on your own time and it will become cled it will become clear what the notes are saying and how that influence what we wrote down below. So here we go. The first thing we'll do when we enter this function is we'll take our list of stringsour list of strings and we'll see how long it is. This will be the number of series that are being requested. If we were to look a little closer in the API documentation for the BLS, we would have seeS, we would have seen that a user without an API key can only request up to 25 series at a time. So if the user has asked for more than 25, we're going to need to make more than one request and here'se request and here's how we do it. If we have more than 25 series, we're going to start by saying that parts is an empty list. Then we're going to establish some common keyword arguments. Like ND or suments. Like ND or start year in API key, these are going to be passed as these three arguments. Two different times. The first time we're going to call the same function we're currently in, but onlyrently in, but only for the first 25 series IDs. And then we'll pass the same start year and year in API key. Then we're going to extend our list with the return value from calling it with the first 2it with the first 25 IDs after that. We're going to call extend again. Or we're going to call this function one more time using IDs starting at the 26th ID until the end of the list. And again, we'rest. And again, we're going to pass the same start year and year in API key. Once that's done, we will have made the request for all the series contained in the series ID argument and we can return thend we can return the list that is parts. This technique of calling a function from within itself is known as recursion or recursive function calls. Here we're utilizing this technique in order to alloque in order to allow the user to specify an arbitrary number of series ID. And then we will do the work of making sure that we adhere to the BLS limits and only request 25 at a time. That's what happme. That's what happens if we did request more than 25. If we requested 25 or less, we fall into this else step. And here's where we actually make a request. On this line, we specify the headers. Thenfy the headers. Then we specify the parameters or the payload for our function or for our API request. We're going to pass the series ID, start year and end year. These names are required and they werequired and they were what the BLS documentation said we needed to have. Then if the user was able to pass us an API key, we're also going to say that we would like to request a catalog. And then we'ltalog. And then we'll attach the API key as the registration key field in the payload. This completes the construction of the payload. And now we need to convert it to JSON. So in the header, we promithe header, we promised we'd be sending JSON. We're going to use the JSON.dumpS function to convert our dictionary into a string of JSON data. And then the S means to turn it to to you as a string. Fiyou as a string. Finally, we're going to actually make the request. So here we're going to use the post function from the request library. We're going to pass the end point or the URL. And the code iURL. And the code is set by passing an argument to the data field of the data parameter to this function. And then the headers are set by passing it to the headers. Once we're done, we're going to ree, we're going to return the output of this function call in a list with the value P. The reason we passed the list here was because in the case that we have more than 25 series IDs, we're going to tus, we're going to turn a list of API responses. And so if we always are returning a list, then the list here is going to be consistent with the list here. And everything will work as expected. So whatas expected. So what we'll do is we'll execute this code cell, which will define our function. So here we see that we have a number, which is Jupiter's way of saying that this function has been definetion has been defined. And now let's do it. Let's try to run this. And if we do this, we will first load up the API key. So now I don't want to post my API key publicly in this video. So I've saved iteo. So I've saved it as an environment variable. You shouldn't have to worry too much about this code. If you are using this and you were able to successfully get me a P. And if you are using this, you are using this, you should replace the right hand side of this with your API key. So your key here, that's a string. So that I don't have to make one public in the video. I will continue to access icontinue to access it from this environment variable. So now we're going to go ahead and grab one series ID. And this was one of the ones I took from the API documentation page. And we're going to makd we're going to make a request for all the data for this particular series between 2010 and 2020. And then we'll pass in our API key. We run this, we'll check the output, and we get a request responset a request response object in return. Our request for series function, it makes the request and it builds the correct payload and headers for us. And it returns to us a list of response objects. Howesponse objects. However, it doesn't do any type of work to validate that the request were successful or that they happened how we wanted. So now we'll write a separate function that will validate orat will validate or verify that our request were successful. Our approach for doing this will be to utilize another part of the HTTP convention. So one part of the standard is that whenever a requestwhenever a request is made as part of the response, the API provider or the web service will provide a status code. Now this code is an integer with three digits. And there are conventions that specinventions that specify what each three digit number represents. All successful responses for getting data are going to be in the 200s, so they're going to be between 200 and 299. So what we'll do now,o what we'll do now, because we were asking for some data, we should get a status code between 200 and 299. And so we will write a function that just checks if the status code on our response was lessur response was less than 300. So here is that function. It takes one argument, which is the response object from the request library. And it's a first extracts the status code. If it is greater thanit is greater than 299, it will raise a Python value error saying we had a response error with a code and it will tell us what the code is. Find this and then in the next cell will apply it to the rel apply it to the response we received. So if you remember our responses was a list of response objects, we're going to access the first and only response here. Ask to check it and it didn't do anythiit didn't do anything. This is great. We would we were expecting this because we didn't have this function have any return value down here. And the only thing that could have happened is a error woulened is a error would have been raised if this status code indicated a failed request. Nothing failed. We didn't see an error. So this is good for our application. Next let's start to look at what isto look at what is inside this response object. There is a content field of the request dot response that returns the data sent from the API. We'll go ahead and run this cell and look what this is. Slook what this is. So this is fairly large and a little bit hard to read as is. But if we look closely, we can see that the type of this looks like a JSON object or a Python dictionary. It has a curlynary. It has a curly brace, a string colon something else. We can actually see if we do responses. Zero got headers. We can see here that the content type. And now this is the content type on the respent type on the response, not our request. They sent us some headers and they set the content type to be application JSON. So our hunch that this looked like JSON is supported by the content types senhe content types sent back by the BLS API. In addition to the content fields, if the response happens to have type JSON, which is very common, the request response object also has a JSON method on it.a JSON method on it. If we call this method, request will do the work to read that into a Python dictionary that we can then use like any other Python dictionary. Now that it's a dictionary instead ofictionary instead of just a string, it's a little easier to use and to read. On the next slide, we're going to unpack kind of the structure of this response. So here, notice that the response had thehe response had the following structure. There were a few different fields at the very front of this dictionary that talked about the request as a whole. Here we see status that the request succeeded.e request succeeded. We have a response time of 190 milliseconds and that there are no extra messages for us. Everything worked as it should have the server didn't need to tell us anything special. Thanything special. Then there's a results field. Now what this says is it is another dictionary or another JSON object that has a series key. This maps to a Python list or a JSON array. And each objectray. And each object in this results.series list has the following structure. We're going to be given a series ID. There's also a catalog field that has another dictionary inside of it with informatiof it with information such as the series title. Here, this particular series ID must represent the total employment or number of people working employees in Apache County, Arizona. Then the series IDsThen the series IDs repeated and there are a number of other fields. Alongside the series ID and catalog, again, if you had an API key and we're able to request a catalog, there is a data field. Heres a data field. Here, the data field is another list and inside of it, there are objects or dictionaries containing the data. So let's look at an example here. We have this is the first item inside thfirst item inside the data list. It has keys year period, period name value and footnotes. You'll see that these same things are repeated over and over. So this is the structure of our return. Now, aour return. Now, a summary of what we just talked about. The actual data that we're after is going to be in our JSON object. Here, we've named that variable Js. So I'll change that to read Js. And tht to read Js. And there's a results field inside of that. There's a series field. Now, the series, the output of this will be a list of dictionaries. Each of those dictionaries will have a series ID,l have a series ID, a catalog, and a data field. The data field has the actual data that we need. And the catalog has some kind of metadata or information about the series. What we'll now need to do n'll now need to do now that we've unpacked the structure that was returned to us is we need to write a Python for a Python function that can operate on one of these dictionaries. So it's going to proco it's going to process the response for a single series. What we'd like to get out of it is a data frame, a pandas data frame with all of this data in it, and then a pandas series that contains all tthat contains all the catalog information. Here is the function we've written that will unpack these series results. You'll see here again, we've included a helpful dox string that described what thet described what the function does. And we're going to dive right into the implementation, and you can look back at the dox string later when you use this later. So the first thing we do is we extractwe do is we extract the series ID from these results and we store that in a variable. Next, we're going to create a pandas data frame from this, the data field of our series results. And thankfully,ts. And thankfully, pandas knows how to read a list of dictionaries and construct a data frame for us. So there's very little work that needs to be done here. And the last thing we'll do with the data'll do with the data is we'll attach the series ID as a new column. So we extracted that on the first line and now we're adding that as an additional column in our data. Then we're going to check to sgoing to check to see if the catalog was returned as part of the series results. If it was, we'll construct a pandas series from that. If it wasn't, we'll just set it to none and finally we'll returnfinally we'll return our data and our metadata. We'll define this function and test it out in the next cell. So here we will make the data frames from our series. We'll call our function. We're goingnction. We're going to pass it just the first value of the first series. And we'll see that our data is the following. And our metadata extracted from the catalog is a pandas series that has all the is that has all the information that described what the series with this code or this ID. So far it looks like our functions are all working for the single example that we tried. And we made our requesd we made our request for earlier. So now we're getting closer. We're nearing the end of writing the code to get the data. And we'll just remind you that the results.series feel of our response objectour response object or response body was a list. The reason for this is that we're going to get one of the series objects for every series ID that we requested when we interacted with the API. What wwith the API. What we need now is to write a function that can take a single response object from the API and process all of the series data inside of it. This will leverage the function we just wrotenction we just wrote, but it will not look at just a single value from this list. It will look at all of the values and return many data frames and many series. Here's what this function looks like agnction looks like again. The helpful doctrines can be read later, but the input now is one response object from the request library. And the body here, the first thing we'll do is we'll compute the JSwe'll compute the JSON form of our response. And then we have one more line of code. So what we do here is we call the map function. So what map does in Python is it takes two arguments. The first isments. The first is the name of a function. Here we're going to pass this make df from series function. We wrote and applied just before. And the second argument is a list or some type of iterator. Intype of iterator. In our case, it is the list that is found at our JSON, RIS response, and then the results series feel. And we're going to, so this map operation will instruct Python to call this funhon to call this function on each of the items in this list. And to follow the map function returns what's called a generator or a lazy way of doing that. And it's not actually going to do the work whng to do the work when the highlighted code finishes. In order to make Python run the functions and do the work, I need to convert this map generator into a Python list by calling the list function. Sthe list function. So now this whole block of code down here after return. We'll work through each of the items in the results series list. Construct our data frame from those contents and then returnents and then return them as a list. Let's test this one out. So now we're going to pass in our one response. We're going to pass into this function and we're going to get back something that I'll calething that I'll call parsed. So we see here, oops, excuse me, I need to define this by running this cell and we'll run it again. And we'll see here that parsed is a list and that it has length 1. Nowit has length 1. Now the reason it has length 1 is because when we initially made our API request, we only asked for data for one series from the BLS. If we look at the first element of parsed, this wnt of parsed, this will be the first value returned from our make dfs from series. Excuse me, the first element of parse and the only element will be what is returned from our make dfs from series. Ifdfs from series. If we look at this, you see that this is a tuple. It contains two objects. The first one is the data frame containing the actual data and the second is the panda series containing thseries containing the metadata information. So again, for the very first BLS series in our request, we're going to get the parsed data from this parsed square bracket zero. And the first item in thisfirst item in this tuple is the data frame and the second is the metadata. So we'll just look at these and we'll see here this is familiar it's what we saw before. The difference this time is that hathis time is that had we made a request for more than one BLS series and we got a response containing multiple series data. We parsed would have a length greater than one and we would be able to do sould be able to do something like parsed one zero to get the data frame for the second series we requested from the BLS. Okay, we're getting close there's one last step. Do you remember back at the vermber back at the very start when we wrote the request for series function? We were given the return object is a list of request responses. If we are requesting more than 25 BLS series, this list willies, this list will have more than one item in it. Our job will then be to unpack all the responses that are returned from the request for series function. We want to concatenate or stack all of the dr stack all of the data that was returned as well as all of the metadata series. So we'll write one last Python function that does this unpacking and then concatenation step. So now here we define a nw here we define a new function this one has one argument that is a list of response objects. And we'll do the following. We're going to say that the unpacked is an empty list and then we'll do a forthen we'll do a for loop over all of the response objects in what was in the argument passed. So for each res in all res, we want to unpack that and remember the unpack response return date list of unturn date list of unpack data. So we're going to extend this empty list recreated with all the items from the list returned by this unpack response. Now this line of code is a little bit tricky or mysle bit tricky or mysterious. And we will leave it to the viewer. I have an assignment for exactly how the zip function works in this context, but effectively what it does is we're going to have the dagoing to have the data underscore ds is just going to be a list of data frames containing all of the raw data in each of the requested series. And the metadata series will be a list of pandas series wt of pandas series with all the catalog information. And once we have that, we can use the pd.com cat function to stack each of these data frames one on top of the other. Creating a long form data seta long form data set. Each of these data frames will have its own index. This is going to be just an integer from zero to the number of rows and it's not meaningful. So we tow pandas that when it doesas that when it does the concatenation, it's safe to ignore the existing index from each of these data frames. And then finally we're going to do something similar. We're going to call the conf-cat fucall the conf-cat function again. For all of our metadata, our all of our pandas series. The contain the catalog or metadata information. And because these are pandas series, what we're first going towe're first going to do is we're going to stack them as separate columns in a data frame. That's what this axis equal one argument does here. Once that's done, we're going to have the row or the indexthe row or the index is going to be the kind of the keys like series ID units, geography. We'd really like those to be columns. So what we'll do is we'll transpose the output. And now the series AD annow the series AD and string version of the series AD will become column names. We'll become columns instead of rows. And this is, makes more sense. You'll notice here that we also have a list comprehhave a list comprehension. Our code is set up that if you don't have an API key, you won't be able to get the catalog information. And this metadata series object here will just be a list of the value a list of the value none. And so what we tell pandas to do is only try to concatenate items from metadata series if the item is not none. Once we've done that, we return our data frame containing alframe containing all of the data and then another data frame containing all of the metadata. Go ahead and we'll execute that. And now all of our functions are defined. This point we're ready to do thwe're ready to do the core data gathering for our unemployment exercise. So with all these functions in place, let's go ahead and put them to use. I've defined for you in the next cell, a list of 108cell, a list of 108 series IDs that contains all of the series IDs at the national US level from the BLS monthly unemployment report. I found these by looking through the BLS website at this monthly ute at this monthly unemployment report and then looking through the source of the data behind their So now with this list of BLS series IDs related to unemployment data, we will execute our code. So wecute our code. So what we'll do first is we'll use the request for series function pass that list of 108 series IDs, specify that we'd like to gather data between the year 2001 and 2020 and then passd 2020 and then pass our API key from above. What we'll get back is a list of requests response objects. Once we have that, we will want to validate or check that they were all completed successfully.pleted successfully. Once that happens, we use our unpack all responses functions to extract all of the data return to us inside of a data frame and then a metadata data frame with the catalog data. Wthe catalog data. We'll go ahead and we'll run this cell. And we'll see what we have. We're waiting here for the previous so making the request to finish. And once it has, we will see the results appsee the results appear here on this slide. So now we see that we have a data frame with 25,596 rows and the six seven columns we were expecting. And our metadata data frame has the information aboute information about what each of these series is for all 108 series IDs that we've asked it. Now what we'll do the last step in this video will be to save the metadata and the raw data to a file on oudata to a file on our computer so that when we want to come back and do further analysis in the future. We don't have to make the same API requests. We're able to just load the data and proceed from ta and proceed from that point. It also makes it easier to share a collaborate with others. As if we give them this notebook, they can see the process we went through to get the data, but then they woua, but then they would just be able to use the file when loading and using the data. So that concludes this video for how you can interact with the API provided by the US Bureau of Labor Statistics. TLabor Statistics. Thank you and see you next time." metadata={'source': 'transcripts_tiny/2.6.3 Using the BLS Api (3 of 4).srt'}