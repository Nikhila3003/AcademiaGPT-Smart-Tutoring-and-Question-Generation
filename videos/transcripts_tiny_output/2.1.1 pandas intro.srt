00:00:00 --> 00:01:05
Hi, this is Chase Coleman. Today we're going to be talking about the Python library pandas. Prior to today, you should have completed the Python fundamentals training. This was something we offered over the summer. At the end of today, you should understand some of the core pandas objects, such as a series and a data frame. You should understand how to index into particular elements of series and data frames, and you should understand some of the basic types that can be stored inside of a series or a data frame. Additionally, as we go, you'll learn how to make some basic visualizations. The outline for today is to talk a little bit about the pandas library to introduce what a series is, and then introduce what a data frame is. To talk about some of the different data types available in pandas, and then to talk about modifying some of the data frames. So, let's go ahead and get started. So, the pandas package will be imported, and typically you'll give it the alias PD. So, we'll write import pandas as PD.

00:01:01 --> 00:02:41
So, we'll write import pandas as PD. Don't worry about what this line does for now, but basically what it does is it's going to allow us to put plots inside of our notebook. And then finally, we're going to activate the QuantyCon data science plotting theme. Now, let's go ahead and figure out what version of pandas everyone has. So, on my computer, I have version 1.1.1, but anything that's higher than 0.25 should be okay. Great. So, the first data type we're going to introduce is called a pandas series. And a series represents a single column of data, and it will be associated with row labels for each observation. And pandas is going to refer to these row labels, which are right here in this case 0.1 and 2, as the index. And we might have named, we might have a name associated with this series. In this case, maybe we just call it S. So, the series named S has an index of 0.1.2, and the values that are stored inside of the series are called, the values. So, on the next slide, we're going to create a series, which includes the US unemployment for every other year,

00:02:34 --> 00:04:10
So, on the next slide, we're going to create a series, which includes the US unemployment for every other year, starting in 1995. So, here we have the values. And here we have each of the years. Notice we started 1995, and we go until 2017, and we take a step by two. So, this will have 1995, 1997, et cetera. And then we're going to create a series by putting the values as the data argument. The years is the index argument, and then we're going to give this series the name unemployment. And let's see what we have. So, we can see, like we just talked in the previous slide, that we have the index right here, and it was this list of years that we talked about. And then over here, we have each of the values that are associated with that index. And we have the name of our series at the bottom. So, we can look at the index where the values notice the values are stored inside of a numpy array, and the index is stored inside of a pandas index object. So, now that we have a series, what can we do with it?

00:04:04 --> 00:05:33
So, now that we have a series, what can we do with it? So, typically our data will have kind of thousands or hundreds of thousands of rows, or maybe even millions or billions of rows. So, we obviously don't want to display all of it at once. And there's two methods for series that will just show us the first few observations, or the last few observations. Anemployment.head will show us the first five, an unemployment.tail will show us the last five. We could also give an argument to either of these of just an integer, and it will show us the last n observations from this series. So, let's go ahead and do some basic plotting. And if we plot a series using the plot method, all it will do is plot the values. So, if we go ahead and look at the values we have, notice 5.6 is associated with 1995. 5.3 is associated with 1997, 4.3 in 99, et cetera, et cetera. And it's created this nice little line plot for us. And as we mentioned earlier, we needed this percent map plot lib in line in order to get the plot to show up in the right place.

00:05:29 --> 00:06:56
in order to get the plot to show up in the right place. So, in this data set, it's not such an interesting observation, but in other data sets, you might be interested in knowing what unique values are in a series. So, for example, if you had a series that had the ages of the individuals in your data set, that might take the values 18, 19, 20, 21, dot, dot, dot until the maximum age. So, again, here it's not interesting because each value is different, but it's something you might do in the future. One of the things that you'll frequently want to do is to select particular elements from a series. And we can use this using the dot lock method or modifier, where index items is going to be some item from inside of the index. So, if we look here, we can see we have our unemployment series, and if we wanted to get the value associated with 1995, all we would do is write dot lock 1995. And if we wanted to get multiple values, maybe we wanted the values from 1995 to 2005 and 2015, we can just give it a list of values and notice extracted the correct values.

00:06:49 --> 00:08:04
we can just give it a list of values and notice extracted the correct values. So, let's take a minute and pause, and we're going to have each of you do some experimentation with these series methods. So, the first thing is we'd like you to display only the first two elements of the series using the head method. We'd like you to use the plot method to make a bar plot. We'll use the dot lock to select the lowest and hide it highest unemployment rate shown in the series, and run the code unemployment.detip below. What does it give you? What do you think it corresponds to? And we'll go ahead and take about five minutes to do this. Okay, welcome back. So, as we saw a few minutes ago, the way to select the first two values from a series using the head method is to do unemployment.net. with the integer two, and it's notice it's selected 1995 and 1997. To do the plotting, we wanted you to investigate the documentation, and recall from our lectures this summer that you can do this by taking the unemployment.plot method

00:07:58 --> 00:09:20
and recall from our lectures this summer that you can do this by taking the unemployment.plot method and putting a question mark after and running the cell. And so that brings up the documentation. And it tells you that the inputs are the series or data frame, the x and y labels, and then what kind of plot you'd like to produce. And notice one of the options is bar. So to make the bar plot, all we have to do is unemployment.plot, kind equals bar, and by default it will set the index as the x-value's, and the values as the y-values. And here we've got a bar plot. To select the minimum in maximum value of unemployment, you might have just looked by hand and noticed 2001, and it was the lowest unemployment in 2011 was the highest, but you also could have used the IDX min and IDX max arguments. And what do these do? Is if you look at IDX min question mark, it returns the row label of the minimum value. If multiple values equal the minimum, the first row label with that value is returned. So this will find us the minimum one,

00:09:18 --> 00:10:59
So this will find us the minimum one, and the maximum one could be done just like it. And then unemployment.detite tells us float 64. So if we look at our unemployment series, just notice that the values themselves are float 64, so unemployment.detite is just telling us what kind of values are being stored inside of our series. Great. So now we've talked about what a series is, and we'll now talk about what a data frame is. So a data frame is just going to be how pandas will store multiple columns of data. You could think about data frames as simply just multiple series stacked side by side. You'll notice that we still have an index, and now the index is zero, we'll just call this column zero, one and two. So index zero is associated with the A in columns zero, the A in column one and the A in column two. Index one is associated with the B in column zero, the B in column one and the B in column two. And the index two is associated with the C in column zero, et cetera, et cetera. So on the next slide, we're going to create a data frame that contains the unemployment rate

00:10:54 --> 00:12:24
So on the next slide, we're going to create a data frame that contains the unemployment rate every other year for each region in the United States starting in 1995. And so what you'll notice is now rather than giving it a given the data frame function, a single list, we're going to give it a dictionary and we're going to say, North East is the key and that maps to the list 5.9, 5.6. South is the key, which maps to the value 5.3, 5.2. And then national is the key that maps to, etc. And we're going to turn that into a data frame and we'll use the same index as we did before, which was years. And then let's just see what that looks like. So notice what it's done is it's taken the list that was associated with each key in the dictionary and it's turned that into a column of data. So the first value in North East was 5.9, then 5.6, 4.4, etc. And notice now these are associated with the index 1995. So in 1995, the Northeast region had an unemployment rate of 5.9, while the Midwest had an unemployment rate of 4.5, the South had an unemployment rate of 5.3,

00:12:19 --> 00:13:42
while the Midwest had an unemployment rate of 4.5, the South had an unemployment rate of 5.3, and the West had an unemployment rate of 6.6, and the national unemployment was 5.6. So again, we can extract the index from our unemployment, and this is the same index that we saw earlier, and we can extract the values from the unemployment region data frame. And notice all this is, is it's a two-dimensional array, it's a matrix. And these values 5.9, 5.6, 4.4 are associated with the values that correspond to Northeast, because it was the first column, 5.9, 5.6, 4.4. So what can we do with a data frame? The answer is pretty much everything we can do with a series and a little more. So just like with the series, we can take the head and the tail of the data frame to give an idea of what our data looks like. Additionally, we can create a plot and notice this plot now has one line for each column in the data frame. And we can index. Now this is going to look a lot like the indexing for a series,

00:13:37 --> 00:15:15
And we can index. Now this is going to look a lot like the indexing for a series, but it's going to be a little bit more complicated because we have to choose from both an index and a column. So let's see how you do that. So if we wanted to get the value that was associated with the unemployment rate in the Northeast in 1995, we would specify 1995 as the index and Northeast as the column. And that gives us the 5.9. If we wanted to get the 1995 and 2005 unemployment for the South, we could give it a list of 1995 and then the South. And notice in this case we were returned just a single number, but because we're now asking for multiple things, it's returned a series to us. And like we can select multiple values from the index, we can also select multiple values from the columns, but notice it's also turned into a series. We can also select an entire column by using the colon. And we also could select an entire row by doing it the other way and notice both of those return a series. You can also select multiple values from both in which case you'll be returned a new data frame.

00:15:07 --> 00:16:36
You can also select multiple values from both in which case you'll be returned a new data frame. And if you don't use the dot lock, it will just extract the column associated with the string you pass in. Great. So now we know how to select data inside of a data frame. What types of things can we do? So we can divide by 100, which moves it from percent units to a rate. And notice it's divided every element of our column by 100. We can find the maximum value. We can subtract one column from another, so we've taken the unemployment in the west and subtracted the unemployment in the Midwest, which just tells us the difference. And we can also compute the correlation between two columns. So the unemployment in the west and the unemployment in the Midwest had a 0.9 correlation. And if we wanted all of the correlations at once, we can simply compute the correlation matrix. So notice it says a northeast is correlated perfectly with the northeast and surprising. It's got a 0.87 correlation with the Midwest,

00:16:29 --> 00:17:45
perfectly with the northeast and surprising. It's got a 0.87 correlation with the Midwest, a 0.96 with the south and the west and a 0.97 with the national unemployment rate. So let's stop for a minute and do another exercise. In this case, we'll continue to encourage using introspection, the tab completion, and GoogleFoo to fulfill the following exercises. Let's find a way to obtain a list that contains all of the column names in the data frame unemployment region. Let's use the plotting method, the plot method, to make a bar plot. What does this look like now and how does it compare to the plot we created with this series? Let's use dot lock to select the unemployment data for the northeast and west in the years 1995, 2005, 2011, and 2015. And let's run the code unemployment region dot detights below. What does this give you? How does this compare to the same thing on the series operation? Welcome back. So let's go over the answers. So there's a property of the data frame called dot columns.

00:17:38 --> 00:18:56
Welcome back. So let's go over the answers. So there's a property of the data frame called dot columns. And notice this just corresponds to the equivalent of dot index, but for the column data. And notice it gives us northeast, Midwest, southwest, and national. We can make the bar plot and notice what it's done is it's plotted each of the columns for each year. So the x-axis is still the indexes, but now we have five different bars for each year. And the color's correspond to the northeast, Midwest, southwest, and national. To select the subset of data we talked about, we can do as we discussed in past two lists. And with detights, notice we were told float 64, but it now gives us a series. So it says, the northeast column has all float data, the Midwest column has all float data, etc. So in the previous exercise, we asked you to run the commands unemployment dot detight and unemployment regions dot detights and to think about the outputs. As we've already discussed, they return the types of

00:18:51 --> 00:19:54
regions dot detights and to think about the outputs. As we've already discussed, they return the types of the values inside of each column. Call them. If we do this with a series, it will just give us a single type. And if we do this with a data frame, it gives us a series that maps the column name into what type of data is stored inside of that column. So it's important that you often check what type of data you're reading into. Pandas, because you can get some things where, if data is not of the type you think it is, that it will miss behave. So let's see for example, so data frames will only distinguish between a few types. They can recognize Boolean's floating point numbers, integers, dates, which we'll talk more about soon, categorical data, and then everything else, including strings, is stored as an object. In the future, we will continue to refer to the data type of data stored in a column as its detight. So let's look more closely at an example of when having an incorrect detight can cause

00:19:49 --> 00:21:05
detight. So let's look more closely at an example of when having an incorrect detight can cause problems. So suppose that we imported this unemployment data from somewhere else, but instead, the data for the South column came as a string. So notice what we've done here is we've created, we've taken the column of the South, and we've turned it into a string data type, and then we've saved it back into that column. And now when we look at string unemployment detights, we see float 64, float 64, and object. So if we just look at the data frame, notice everything looks okay, we can't, you don't notice that the South is of type string, but if we try to do something like compute the sum, you'll get something weird. So notice for the northeast Midwest and national, it's performed to the sum as we might expect, but when we sum to the South, it's just taken all of the unemployment rates, and it's tied the strings together. And this happens because dot sum is just calling plus between each of the rows in a column,

00:20:59 --> 00:22:04
And this happens because dot sum is just calling plus between each of the rows in a column, and when we add two strings, the result is the two strings being concatenated. And so right here, all we've done is concatenate all of the strings. So these types of errors will pop up unexpectedly, and it's useful to check what type your data is. Now let's go ahead and talk about how we can change the data inside of a data frame in various ways. In particular, we'll talk about adding new columns, renaming the index labels or column names, and altering the data inside of the data frame. Some of these will be discussed at length later in the class, but we'll just give a brief introduction. So to create a new column, you can take the data frame, we'll often abbreviate our data frames as a DF, and we can give it a new name and strings and assign it to the values. So let's see how we could do that. So we could create unemployment region, a new column called unweighted mean, and we could do that by adding

00:21:57 --> 00:23:17
So we could create unemployment region, a new column called unweighted mean, and we could do that by adding the northeast, Midwest, South, and west unemployment regions, and then dividing by four. And notice if we do that, we now have the national mean, which is going to be population-weighted, and the unweighted mean, which is what we just performed right here. You can also change the values inside of a data frame. Again, you should do this very sparingly because you don't want to change the data that you're using. So in this case, we're going to take the 1995 unweighted mean value, and we're going to assign it to zero. And so now in the year 1995, the unweighted mean has been reset to the value zero. And we can also rename columns. So one of my favorite examples that's entirely frustrating is the Bureau of Labor Statistics here in the United States, names their regional unemployment rate according to the following protocol. LASRD 91000000000000000303.dot.dot. And you're supposed to know that that's the unemployment

00:23:06 --> 00:24:19
LASRD 91000000000000000303.dot.dot. And you're supposed to know that that's the unemployment rate for the northeast. So they have reasons internally for doing this because they have so many variables, but it makes our job really difficult because we'll need to type it repeatedly. And so what we'll do is we'll often rename these columns by passing a dictionary to the rename method. And what you do is you take a dictionary and you take the value that it currently is. In this case, northeast, Midwest, south, and west, and that will be the key of your dictionary. And the value of your dictionary will be the new name. So in this case, we have NEMWS and W. And so if we look at our data frame, it looks like things have been renamed. Well, maybe not. So what happened here? Why does the data frame show that why does the data frame still show the old column names? The reason is, most panda operations are going to create a copy of your data. And to specify that you meant to overwrite your data frame,

00:24:12 --> 00:25:05
are going to create a copy of your data. And to specify that you meant to overwrite your data frame, you have to use the in-place option. We recommend that you avoid using this too much until you understand exactly what you're changing because you don't want to overwrite your data. And we'll often just create the new data frame and assign it back to something of the same name. So in this case, we've renamed our columns and this creates a new data frame. And then we've assigned it to unemployment short name and in the short name data frame, we now have the renamed columns. And that's all we have for this lecture. So we'll see you soon to talk about pandas basics.

