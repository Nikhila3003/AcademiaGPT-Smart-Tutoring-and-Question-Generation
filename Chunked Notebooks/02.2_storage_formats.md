page_content='**Prerequisites**  \n- [Intro to DataFrames and Series](../p01_pandas_intro/v01_pandas_intro.ipynb)  \n**Outcomes**  \n- Understand that data can be saved in various formats\n- Know where to get help on file input and output\n- Know when to use csv, xlsx, feather, and sql formats  \n**Data**  \n- Results for all NFL games between September 1920 to February 2017' metadata={'Header 1': 'Storage Formats'}page_content='- [Storage Formats](#Storage-Formats)\n- [File Formats](#File-Formats)\n- [Writing DataFrames](#Writing-DataFrames)\n- [Reading Files into DataFrames](#Reading-Files-into-DataFrames)\n- [Practice](#Practice)  \n```python' metadata={'Header 1': 'Storage Formats', 'Header 2': 'Outline'}page_content='#! pip install qeds\n```  \n```python\nimport pandas as pd\nimport numpy as np\n```' metadata={'Header 1': 'Uncomment following line to install on colab'}page_content='Data can be saved in a variety of formats  \npandas understands how to write and read DataFrames to and from many of\nthese formats  \nWe defer to the [official\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/io.html)\nfor a full description of how to interact with all the file formats, but\nwill briefly discuss a few of them here' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'File Formats'}page_content='**What is it?** CSVs store data as plain text (strings) where each row is a\nline and columns are separated by `,`' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'CSV'}page_content='- Widely used (you should be familiar with it)\n- Plain text file (can open on any computer, “future proof”)\n- Can be read from and written to by most data software' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'CSV', 'Header 3': 'CSV: Pros'}page_content='- Not the most efficient way to store or access\n- No formal standard, so there is room for user interpretation on how to\nhandle edge cases (e.g. what to do about a data field that itself includes\na comma)' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'CSV', 'Header 3': 'CSV: Cons'}page_content='- A great default option for most use cases' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'CSV', 'Header 3': 'CSV: When to use'}page_content='**What is it?** xlsx is a binary file format used as Excel’s default.' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'xlsx'}page_content='- Standard format in many industries\n- Easy to share with colleagues that use Excel' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'xlsx', 'Header 3': 'xlsx: Pros'}page_content='- Quite slow to read/write large amounts of data\n- Stores both data and *metadata* like styling and display information\nand even plots. This metadata is not always portable to other file formats\nor programs.\n- Non-human readable' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'xlsx', 'Header 3': 'xlsx: Cons'}page_content='**When to use**:  \n- When sharing data with Excel\n- When you would like special formatting to be applied to the\nspreadsheet when viewed in Excel' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'xlsx', 'Header 3': 'xlsx: When to use'}page_content='**What is it?** Parquet is a custom binary format designed for efficient reading and\nwriting of data stored in columns.' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Parquet'}page_content='- *Very* fast\n- Naturally understands all `dtypes` used by pandas, including\nmulti-index DataFrames\n- Very common in “big data” systems like Hadoop or Spark\n- Supports various compression algorithms' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Parquet', 'Header 3': 'Parquet: pros'}page_content='- Binary storage format that is not human-readable' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Parquet', 'Header 3': 'Parquet: Cons'}page_content='- If you have “not small” amounts (> 100 MB) of unchanging data that\nyou want to read quickly\n- If you want to store data in an size-and-time-efficient way that may\nbe accessed by external systems' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Parquet', 'Header 3': 'Parquet: When to use'}page_content='**What is it?** Feather is a custom binary format designed for efficient reading and\nwriting of data stored in columns.' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Feather'}page_content='- *Very* fast – even faster than parquet\n- Naturally understands all `dtypes` used by pandas' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Feather', 'Header 3': 'Feather: Pros'}page_content='- Can only read and write from Python and a handful of other\nprogramming languages\n- New file format (introduced in March ‘16), so most files don’t come\nin this format\n- Only supports standard pandas index, so you need to `reset_index`\nbefore saving and then `set_index` after loading' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Feather', 'Header 3': 'Feather: Cons'}page_content='- Use as an alternative to Parquet if you need the absolute best read and write\nspeeds for unchanging datasets\n- Only use when you will not need to access the data in a programming language\nor software outside of Python, R, and Julia' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Feather', 'Header 3': 'Feather: When to use'}page_content='**What is it?** SQL is a language used to interact with relational\ndatabases… [more info](https://en.wikipedia.org/wiki/SQL)' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'SQL'}page_content='- Well established industry standard for handling data\n- Much of the world’s data is in a SQL database somewhere' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'SQL', 'Header 3': 'SQL: Pros'}page_content='- Complicated: to have full control you need to learn another language\n(SQL)' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'SQL', 'Header 3': 'SQL: Cons'}page_content='- When reading from or writing to existing SQL databases  \n**NOTE**: We will likely cover interacting with SQL databases in a later lecture' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'SQL', 'Header 3': 'SQL: When to use'}page_content='TODO: check what the S means, might just be "script"  \n**What is is?** JSON is an acronym for "Javascript serialized object notation". It is a very common way to store data, especially when interacting with web services.  \nData is stored almost how we would write a Python `dict` by hand using `{` and `}` to provide  key, value pairs' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'JSON'}page_content='- Very commonly used when interacting with websites and web apis\n- Maps naturally into a Python dict\n- Human readable\n- Can store non-tabular data (each record or row can have different keys)' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'JSON', 'Header 3': 'JSON: Pros'}page_content='- Relatively inefficient when stored as an array of records (must repeat column names for every row)\n- Non-binary, so can be slow to read and write\n- Ambiguous for how to represent certain data (array of records, record of arrays by column, record of arrays by row, etc.)' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'JSON', 'Header 3': 'JSON: Cons'}page_content='- When recieving data from or preparing data for web APIs\n- When you want to store relatively small amounts of non or semi-structured data' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'JSON', 'Header 3': 'JSON: When to use'}page_content='Let’s now talk about saving a DataFrame to a file.  \n**Rule of thumb**: To save `df` to a file of type `FOO` use `df.to_FOO`  \nWe\'ll test this out for a few of the data formats above using some artificial data  \n**Note**: by default `df2` will be approximately 10 MB. You can change this by adjusting `wanted_mb` in the cell below  \n```python\nnp.random.seed(42)  # makes sure we get the same random numbers each time\ndf1 = pd.DataFrame(\nnp.random.randint(0, 100, size=(10, 4)),\ncolumns=["a", "b", "c", "d"]\n)  \nwanted_mb = 10  # CHANGE THIS LINE\nnrow = 100000\nncol = int(((wanted_mb * 1024**2) / 8) / nrow)\ndf2 = pd.DataFrame(\nnp.random.rand(nrow, ncol),\ncolumns=["x{}".format(i) for i in range(ncol)]\n)  \nprint("df2.shape = ", df2.shape)\nprint("df2 is approximately {} MB".format(df2.memory_usage().sum() / (1024**2)))\n```' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Writing DataFrames'}page_content='Let’s start with `df.to_csv`  \nWithout any additional arguments, the `df.to_csv` function will return\na string containing the csv form of the DataFrame:  \n```python' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Writing DataFrames', 'Header 3': '[df.to_csv](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_csv.html)'}page_content='print(df1.to_csv())\n```  \nIf we do pass an argument, the first argument will be used as the file name.  \n```python\ndf1.to_csv("df1.csv")\n```  \nRun the cell below to verify that the file was created.  \n```python\nimport os\nos.path.isfile("df1.csv")\n```  \nLet’s see how long it takes to save `df2` to a file. (Because of the `%%time` at\nthe top, Jupyter will report the total time to run all code in\nthe cell)  \n```python\n%%time\ndf2.to_csv("df2.csv")\n```  \nAs we will see below, this isn’t as fastest file format we could choose.' metadata={'Header 1': "notice the plain text format -- one row per line, columns separated by `'`"}page_content='The `df.to_excel` method writes a DataFrame to an excel workbook  \nThe first argument is the name of the file  \nThe second argument is the name of the sheet in that file (this is optional, and is `Sheet1` by default)  \n```python\ndf1.to_excel("df1.xlsx", "df1")\n```  \nWe can write multiple DataFrames to a single workbook, eacn in a different sheet  \nTo do this we use `pd.ExcelWriter(filename)` and then pass the returned object instead of a file name to `df.to_excel`:  \n```python\nwith pd.ExcelWriter("df1.xlsx") as writer:\ndf1.to_excel(writer, "df1")\n(df1 + 10).to_excel(writer, "df1 plus 10")\n```  \nThe  \n```python\nwith ... as ... :\n```  \nsyntax used above is an example of a *context manager*  \nWe don’t need to understand all the details behind what this means\n(google it if you are curious)  \nFor our purposes we used it so that Python could:  \n1. create the `df1.xlsx` file\n2. Ensure that the file remains open while pandas writes the two DataFrames\n3. Close the file when finished to finalize storing data  \n<p style="color:red;">  \nWARNING:  \n</p>  \nSaving `df2` to an excel file takes a very long time.  \nFor that reason, we will just show the code and hard-code the output\nwe saw when we ran the code.  \n```python\n%%time\ndf2.to_excel("df2.xlsx")\n```  \n```python\nWall time: 25.7 s\n```' metadata={'Header 1': "notice the plain text format -- one row per line, columns separated by `'`", 'Header 3': '[df.to_excel](https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.to_excel.html)'}page_content='As noted above, the feather file format was developed for very efficient\nreading and writing between Python and your computer  \nSupport for this format is provided by a separate Python package called `pyarrow`  \nThis package is not installed by default  \nIf you do not have it, but would like to install `pyarrow`, uncomment and execute the cell below  \n```python' metadata={'Header 1': "notice the plain text format -- one row per line, columns separated by `'`", 'Header 3': '[pyarrow.feather.write_feather](https://arrow.apache.org/docs/python/generated/pyarrow.feather.write_feather.html#pyarrow.feather.write_feather)'}page_content='```  \nThe parameters for `pyarrow.feather.write_feather` are the DataFrame and file name  \nLet’s try it out  \n```python\nimport pyarrow.feather\npyarrow.feather.write_feather(df1, "df1.feather")\n```  \n```python\n%%time\npyarrow.feather.write_feather(df2, "df2.feather")\n```  \nAn example timing result:  \n|format|time|\n|:---------:|:----------------------:|\n|csv|2.66 seconds|\n|xlsx|25.7 seconds|\n|feather|43 milliseconds|  \nAs you can see, saving this DataFrame in the feather format was far\nfaster than either CSV or Excel.' metadata={'Header 1': '%pip install pyarrow'}page_content='As with the `df.to_FOO` family of methods, there are similar\n`pd.read_FOO` functions. (Note: they are in defined pandas, not as\nmethods on a DataFrame.)  \nThese methods have many more options because data storage can be messy or wrong  \nWe will explore these in more detail in a separate lecture  \nFor now, we just want to highlight the differences in how to read data\nfrom each of the file formats  \nLet’s start by reading the files we just created to verify that they\nmatch the data we began with  \n```python' metadata={'Header 1': '%pip install pyarrow', 'Header 2': 'Reading Files into DataFrames'}page_content='df1_csv = pd.read_csv("df1.csv", index_col=0)\ndf1_csv.head()\n```  \n```python\ndf1_xlsx = pd.read_excel("df1.xlsx", "df1", index_col=0)\ndf1_xlsx.head()\n```  \n```python' metadata={'Header 1': 'notice that index was specified in the first (0th -- why?) column of the file'}page_content='df1_feather = pyarrow.feather.read_feather("df1.feather")\ndf1_feather.head()\n```  \n`pd.read_FOO`functions can read files stored online  \nTo do this, we pass a URL as the first argument:  \n```python\ndf1_url = "https://storage.googleapis.com/workshop_materials/df1.csv"\ndf1_web = pd.read_csv(df1_url, index_col=0)\ndf1_web.head()\n```' metadata={'Header 1': 'notice feather already knows what the index is'}page_content='Now it’s your turn…  \nIn the cell below, the variable `url` contains a web address to a csv\nfile containing the result of all NFL games from September 1920 to\nFebruary 2017  \nYour task is to do the following:  \n- Use `pd.read_csv` to read this file into a DataFrame named `nfl`\n- Print the shape and column names of `nfl`\n- Save the DataFrame to a file named `nfl.xlsx`\n- Open the spreadsheet using Excel on your computer  \nIf you finish quickly, do some basic analysis of the data. Try to do\nsomething interesting. If you get stuck, here are some suggestions for\nwhat to try:  \n- Compute the average total points in each game (note, you will need to\nsum two of the columns to get total points).\n- Repeat the above calculation, but only for playoff games.\n- Compute the average score for your favorite team (you’ll need to\nconsider when they were team1 vs team2).\n- Compute the ratio of “upsets” to total games played. An upset is\ndefined as a team with a lower ELO winning the game.  \n```python\nurl = "https://raw.githubusercontent.com/fivethirtyeight/nfl-elo-game/"\nurl = url + "3488b7d0b46c5f6583679bc40fb3a42d729abd39/data/nfl_games.csv"' metadata={'Header 1': 'notice feather already knows what the index is', 'Header 2': 'Practice'}page_content='```' metadata={'Header 1': 'your code here --- create more cells if necessary'}page_content='If you want to remove the files we just created, run the following cell.  \n```python\ndef try_remove(file):\nif os.path.isfile(file):\nos.remove(file)  \nfor df in ["df1", "df2"]:\nfor extension in ["csv", "feather", "xlsx"]:\nfilename = df + "." + extension\ntry_remove(filename)\n```  \n```python  \n```' metadata={'Header 1': 'your code here --- create more cells if necessary', 'Header 3': 'Cleanup'}