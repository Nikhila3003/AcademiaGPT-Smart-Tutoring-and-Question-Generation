page_content='**Attribution**: _This notebook is based on a notebook created by Dave Backus, Chase Coleman, Brian LeBlanc, and Spencer Lyon for the NYU Stern Data Bootcamp course_  \n```python\nimport matplotlib.pyplot as plt\nimport pandas as pd  \nfrom urllib.parse import urljoin  \n%matplotlib inline\n```' metadata={'Header 1': 'Pandas Review: UN Population Data'}page_content="We will look at the UN's [population data](http://esa.un.org/unpd/wpp/Download/Standard/Population/). In this notebook, we will focus specifically the age distribution of the population." metadata={'Header 1': 'Pandas Review: UN Population Data', 'Header 2': 'UN Population Data'}page_content='The population numbers for a particular year are reported as corresopnding to 1 July 2020. There will be two types of population numbers that we discuss:  \n* *estimates*: Estimates of the population at a point in the past\n* *projections*: Forecasts of what the population might be for a given year  \nFurthermore, the UN will provide various versions of the projections using different modeling assumptions. We will consider three of their population models:  \n1. *Low variant*: Assumes a low fertility with normal mortality and normal migration.\n2. *Medium variant*: Assumes a medium fertility with normal mortality and normal migration.\n3. *High variant*: Assumes a high fertility with normal mortality and normal migration' metadata={'Header 1': 'Pandas Review: UN Population Data', 'Header 2': 'UN Population Data', 'Header 3': 'Projection Variants'}page_content='We start, as usual, by loading the data.  This will take a minute because the file is about 10 MB in size.  \n```python\nun_base_url = "https://population.un.org/"\npath_to_file = "wpp/Download/Files/1_Indicators%20(Standard)/EXCEL_FILES/2_Population/"\nfilename = ("WPP2022_POP_F02_1_POPULATION_5-YEAR_AGE_GROUPS_BOTH_SEXES.xlsx")  \nurl = urljoin(un_base_url, path_to_file+filename)\n```  \n```python\ncols_to_read = [\n"Variant", "Region, subregion, country or area *", "Location code",\n"Type", "Year"\n]  \nage_cols = [f"{5*i}-{5*i+4}" for i in range(20)]\nage_cols.append("100+")  \ncols_to_read.extend(age_cols)  \nsheets = pd.read_excel(\nurl, sheet_name=["Estimates", "Low variant", "Medium variant", "High variant"],\nskiprows=16, usecols=cols_to_read, na_values=["..."]\n)  \nest = sheets["Estimates"]\nlow_proj = sheets["Low variant"]\nmed_proj = sheets["Medium variant"]\nhgh_proj = sheets["High variant"]' metadata={'Header 1': 'Pandas Review: UN Population Data', 'Header 2': 'UN Population Data', 'Header 3': 'Loading the data'}page_content='df = pd.concat([est, low_proj, med_proj, hgh_proj], axis=0, ignore_index=True)\n```  \nWhat does our data contain?  \n```python\ndf.head()\n```  \n```python\nprint("Dimensions and dtypes of estimates:")\nprint(df.shape)\nprint(df.dtypes)\n```' metadata={'Header 1': 'Combine all of the datasets into one'}page_content='The first step to using this data is to make sure that the data is clean.  \n```python\ndf.head()\n```  \n**Geography types**  \nThere are currently many different geography types including `World`, `Label/Separator`, `Development Group`, `Income Group`, ..., and `Country/Area`.  \nFor what we\'re going to do today, we\'re going to focus on country level information.  \n```python\ndf = df.query("Type == \'Country/Area\'")  \ndf.head()  \n```  \n**Renaming**  \nMany column names aren\'t easily typable or usable. We will resolve this by renaming the columns and will use the conventions below for renaming our columns:  \n* Short and memorable (using standard conventions where possible)\n* Lower case with underscores to separate words when needed\n* Consistent <- Most important  \n```python\nrenamers = {\n"Variant": "variant",\n"Region, subregion, country or area *": "country",\n"Location code": "alpha3",\n"Type": "type",\n"Year": "year"\n}' metadata={'Header 1': 'Combine all of the datasets into one', 'Header 3': 'Clean data'}page_content='df = df.rename(\ncolumns=renamers\n).drop(\n["type"], axis=1\n)  \ndf.head()  \n```  \n```python' metadata={'Header 1': 'to just countries)'}page_content='df["year"] = df["year"].astype(int)\n```  \n**Reshaping**  \nThe data currently has one column for each age group. We\'ll update the data to be a long-form rather than wide-form to make it "tidy"  \n```python\ndf = df.melt(id_vars=["variant", "country", "alpha3", "year"], var_name="age")  \ndf.head()  \n```  \n**Population sizes**  \nLet\'s focus on countries that had more than 50,000,000 people in 2010, 2015, and 2020 according to the estimates data.  \nIn order to do this, we\'re going to use a pivot table to determine how many people were in each country during each year and then use boolean selection  \n```python' metadata={'Header 1': 'so now we can move the year back to an integer as it should be'}page_content='pop_sizes = (\ndf.query("variant == \'Estimates\'")\n.pivot_table(index="country", columns="year", values="value", aggfunc="sum")\n)' metadata={'Header 1': 'Sum up over all age-groups'}page_content='countries_pop_gt_50m_bool = (pop_sizes.loc[:, 2010:2020] > 50_000).all(axis=1)\ncountries_pop_gt_50m = countries_pop_gt_50m_bool.index[countries_pop_gt_50m_bool].tolist()\n```  \n```python\ncountries_pop_gt_50m\n```  \n```python\ndf_gt_50m = df.query("country in @countries_pop_gt_50m")  \ndf_gt_50m.head()  \n```' metadata={'Header 1': 'Get list of the countries with more than 50m people'}page_content='Let\'s now begin visually exploring our data.  \n**Plotting age distribution**  \nBelow, we\'ll begin plotting the age distributions of certain countries in different years. Let\'s start by plotting the age distribution in China for 1960, 1990, 2020, 2050, and 2080.  \nTo do this, we  will need `year` on the index and `age` as the columns.  \n```python\nchina_sel = "country == \'China\' & (variant==\'Estimates\' | variant==\'Medium\')"\ndf_china = (\ndf.query(china_sel)\n.pivot_table(index="age", columns="year", values="value")\n.loc[:, range(1960, 2100, 30)]\n)  \n```  \n```python\nax = df_china.plot(\nkind="bar", figsize=(10, 8), subplots=True, sharey=True,\nlegend=False\n)  \nfig = ax[0].get_figure()\nfig.tight_layout()\n```  \nWhat\'s wrong with the graph?  \n```python\nax = df_china.loc[age_cols, :].plot(\nkind="bar", figsize=(10, 8), subplots=True, sharey=True,\nlegend=False\n)  \nfig = ax[0].get_figure()\nfig.tight_layout()\n```  \nMaybe we want to see the fraction of the population in each bin rather than the number of people  \n```python\nax = (\ndf_china.divide(df_china.sum(axis=0), axis=1)\n.loc[age_cols, :]\n.plot(\nkind="bar", figsize=(10, 8), subplots=True,\nsharey=True, legend=False, ylim=(0.0, 0.2),\ntitle="Population Share by Age Bracket"\n)\n)  \nfor (i, _ax) in enumerate(ax):\n_population_m = df_china.iloc[:, i].sum()/1000\n_title = f"{df_china.columns[i]}: {_population_m:.2f} million"\n_ax.set_title("")\n_ax.set_title(_title, loc="right")\n_ax.spines["right"].set_visible(False)\n_ax.spines["top"].set_visible(False)  \nfig = ax[0].get_figure()\nfig.tight_layout()  \n```  \nIf we wanted a similar graph for another country, we could potentially copy and paste what we wrote, but, if we made minor changes then we could potentially introduce unexpected errors when trying to write them.  \nInstead, let\'s write a function that creates a graph like this.  \n```python\ndef age_distribution_graph(data, country, years, forecast_variant="Medium"):' metadata={'Header 1': 'Get list of the countries with more than 50m people', 'Header 3': 'Visualizations'}page_content='sel = f"country == \'{country}\' & (variant==\'Estimates\' | variant==\'{forecast_variant}\')"\nplot_df = (\ndata.query(sel)\n.pivot_table(index="age", columns="year", values="value")\n.loc[:, years]\n)' metadata={'Header 1': 'Subset the data'}page_content='ax = (\nplot_df.divide(plot_df.sum(axis=0), axis=1)\n.loc[age_cols, :]\n.plot(\nkind="bar", figsize=(10, 8), subplots=True,\nsharey=True, legend=False, ylim=(0.0, 0.2),\ntitle=None\n)\n)  \nfor (i, _ax) in enumerate(ax):\n_population_m = plot_df.iloc[:, i].sum()/1000\n_title = f"{plot_df.columns[i]}: {_population_m:.2f} million"\n_ax.set_title("")\n_ax.set_title(_title, loc="right")\n_ax.spines["right"].set_visible(False)\n_ax.spines["top"].set_visible(False)  \nfig = ax[0].get_figure()\nax[0].set_title(f"Population Share by Age Bracket for {country}", loc="left")\nfig.tight_layout()  \nreturn fig  \n```' metadata={'Header 1': 'Create the plot'}page_content='```python\nyears_of_interest = [1980, 1990, 2000, 2020, 2050, 2100]\n```  \n**China**  \n```python\nage_distribution_graph(df, "China", years_of_interest, "Low");\n```  \n```python\nage_distribution_graph(df, "China", years_of_interest, "Medium");\n```  \n```python\nage_distribution_graph(df, "China", years_of_interest, "High");\n```  \n**India**  \n```python\nage_distribution_graph(df, "India", years_of_interest, "Low");\n```  \n```python\nage_distribution_graph(df, "India", years_of_interest, "Medium");\n```  \n```python\nage_distribution_graph(df, "India", years_of_interest, "High");\n```  \n**United States of America**  \n```python\nage_distribution_graph(df, "United States of America", years_of_interest, "Low");\n```  \n```python\nage_distribution_graph(df, "United States of America", years_of_interest, "Medium");\n```  \n```python\nage_distribution_graph(df, "United States of America", years_of_interest, "High");\n```' metadata={'Header 1': 'Create the plot', 'Header 3': 'Population graphs'}page_content='Lots of reasons, but one that we (as young working-age adults) should be particularly interested in is social security programs.  \n_Definition: **Dependency ratio**_  \n> The (old-age) dependency ratio relates the number of persons aged 65 or over per 100 persons aged 15-64.  \nWe care about this measurement because it tells us roughly how many working age people there are to support those who have stopped working. As the population distribution shifts to the right (and if nothing changes), there will be fewer individuals to support the social security programs that support the old (non-working) population.  \n```python' metadata={'Header 1': 'Create the plot', 'Header 2': 'Why do we care about age distribution?'}page_content='working_age = [f"{5*i}-{5*i + 4}" for i in range(20) if 5*i >= 15 and 5*i<65]\nold_age = [f"{5*i}-{5*i + 4}" for i in range(20) if 5*i>=65] + ["100+"]  \ndf_gt_50m.loc[:, "age_classification"] = "young"\nwa = df_gt_50m["age"].isin(working_age)\ndf_gt_50m.loc[wa, "age_classification"] = "work"\noa = df_gt_50m["age"].isin(old_age)\ndf_gt_50m.loc[oa, "age_classification"] = "old"  \ndr = (\ndf_gt_50m.query("variant == \'Estimates\' | variant == \'Medium\'")\n.pivot_table(\nindex=["country", "year"],\ncolumns="age_classification", values="value"\n)\n)  \ndr.loc[:, "dep_ratio"] = 100 * (dr.loc[:, "old"] / dr.loc[:, "work"])  \ndr = dr["dep_ratio"].unstack(level="country")  \ndr.head()  \n```  \n**Sustainable dependency ratio**  \nObviously the age of retirement could be adjusted which would make the dependency ratio, as we\'ve calculated it, a worse measure of dependence. However, just as a thought experiment, let\'s suppose that the dependency ratio that is sustainable long term (i.e. the payments to social security are roughly the same as the social security tax collected) is 50 (which means that there are 2 workers for each person over 65).  \nOf our countries with over 50 million citizens, how many countries will be sustainable in 2080? In 2100?  \n```python\nfig, ax = plt.subplots(figsize=(8, 6))  \ndr.plot(kind="line", ax=ax, legend=False)\nax.hlines(50, 1950, 2100, color="k", linewidth=2.0, linestyle="--")  \nax.spines["top"].set_visible(False)\nax.spines["right"].set_visible(False)  \nax.set_title("Dependency Ratios for countries with 50m+ citizens")\n```  \n```python\ndr_2080 = dr.loc[2080, :]\ndr_2080.index[dr_2080 < 50]\n```  \n```python\ndr_2100 = dr.loc[2100, :]\ndr_2100.index[dr_2100 < 50]\n```' metadata={'Header 1': '50,000,000 people'}