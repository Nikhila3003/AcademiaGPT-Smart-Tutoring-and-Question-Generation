page_content='**Co-author**  \n> - [Kim Ruhl *University of Wisconsin*](http://kimjruhl.com)  \n**Prerequisites**  \n- [matplotlib Introduction](https://datascience.quantecon.org/../pandas/matplotlib.html)\n- [Visualization Rules](https://datascience.quantecon.org/visualization_rules.html)  \n**Outcomes**  \n- Use geopandas to create maps  \n```python' metadata={'Header 1': 'Mapping in Python'}page_content='#! pip install fiona geopandas xgboost gensim folium pyLDAvis descartes\n```  \n```python\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport pandas as pd  \nfrom shapely.geometry import Point  \n%matplotlib inline\n```' metadata={'Header 1': 'Uncomment following line to install on colab'}page_content='In this lecture, we will use a new package, `geopandas`, to create maps.  \nMaps are really quite complicated… We are trying to project a spherical surface onto a flat figure, which is an\ninherently complicated endeavor.  \nLuckily, `geopandas` will do most of the heavy lifting for us.  \nLet’s start with a DataFrame that has the latitude and longitude coordinates of various South American cities.  \nOur goal is to turn them into something we can plot – in this case, a `GeoDataFrame`.  \n```python\ndf = pd.DataFrame({\n\'City\': [\'Buenos Aires\', \'Brasilia\', \'Santiago\', \'Bogota\', \'Caracas\'],\n\'Country\': [\'Argentina\', \'Brazil\', \'Chile\', \'Colombia\', \'Venezuela\'],\n\'Latitude\': [-34.58, -15.78, -33.45, 4.60, 10.48],\n\'Longitude\': [-58.66, -47.91, -70.66, -74.08, -66.86]\n})\n```  \n```python\ndf\n```  \nIn order to map the cities, we need tuples of coordinates.  \nWe generate them by zipping the latitude and longitude together to store them in a new column named `Coordinates`.  \n```python\ndf["Coordinates"] = list(zip(df.Longitude, df.Latitude))\ndf.head()\n```  \nOur next step is to turn the tuple into a `Shapely` `Point` object.  \nWe will do this by applying Shapely’s `Point` method to the `Coordinates` column.  \n```python\nx = Point(5, 5)\ny = Point(10, 10)\n```  \n```python\nx.distance(y)\n```  \n```python\n(5**2 + 5**2)**0.5\n```  \n```python\ndf["Coordinates"] = df["Coordinates"].apply(Point)\ndf.head()\n```  \nFinally, we will convert our DataFrame into a GeoDataFrame by calling the\ngeopandas.DataFrame method.  \nConveniently, a GeoDataFrame is a data structure with the convenience of a\nnormal DataFrame but also an understanding of how to plot maps.  \nIn the code below, we must specify the column that contains the geometry data.  \nSee this excerpt from the docs  \n> The most important property of a GeoDataFrame is that it always has one GeoSeries column that\nholds a special status. This GeoSeries is referred to as the GeoDataFrame’s “geometry”. When a\nspatial method is applied to a GeoDataFrame (or a spatial attribute like area is called), this\ncommands will always act on the “geometry” column.  \n```python\ngdf = gpd.GeoDataFrame(df, geometry="Coordinates")\ngdf.head()\n```  \n```python' metadata={'Header 1': 'Uncomment following line to install on colab', 'Header 2': 'Mapping in Python'}page_content="print('gdf is of type:', type(gdf))" metadata={'Header 1': "Doesn't look different than a vanilla DataFrame...let's make sure we have what we want"}page_content="print('\\nThe geometry column is:', gdf.geometry.name)\n```" metadata={'Header 1': 'And how can we tell which column is the geometry column?'}page_content='Great, now we have our points in the GeoDataFrame.  \nLet’s plot the locations on a map.  \nThis will require 3 steps  \n1. Get the map\n1. Plot the map\n1. Plot the points (our cities) on the map' metadata={'Header 1': 'And how can we tell which column is the geometry column?', 'Header 3': 'Plotting a Map'}page_content='An organization called [Natural Earth](https://www.naturalearthdata.com/) compiled the map data\nthat we use here.  \nThe file provides the outlines of countries, over which we’ll plot the city locations\nfrom our GeoDataFrame.  \nLuckily, `geopandas` already comes bundled with this data, so we don’t\nhave to hunt it down!  \n```python' metadata={'Header 1': 'And how can we tell which column is the geometry column?', 'Header 3': 'Plotting a Map', 'Header 4': '1. Get the map'}page_content='world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))\nworld = world.set_index("iso_a3")  \nworld.head()\n```  \n```python\ntza = world.loc["TZA", "geometry"]\n```  \n```python\ntza.boundary\n```  \n```python\ntza.boundary.xy[0]\n```  \n```python\ntza.boundary.xy[1]\n```  \n```python' metadata={'Header 1': 'Grab low resolution world file'}page_content='tza.boundary\n```  \n```python\nplt.plot(tza.boundary.xy[0], tza.boundary.xy[1])\n```  \n`world` is a GeoDataFrame with the following columns:  \n- `pop_est`: Contains a population estimate for the country\n- `continent`: The country’s continent\n- `name`: The country’s name\n- `iso_a3`: The country’s 3 letter abbreviation (we made this the index)\n- `gdp_md_est`: An estimate of country’s GDP\n- `geometry`: A `POLYGON` for each country (we will learn more about these soon)  \n```python\nworld.geometry.name\n```  \nNotice that the geometry for this GeoDataFrame is stored in the `geometry` column.  \n**A quick note about polygons**  \nInstead of points (as our cities are), the geometry objects are now polygons.  \nA polygon is what you already likely think it is – a collection of ordered points\nconnected by straight lines.  \nThe smaller the distance between the points, the more readily the polygon can approximate\nnon-linear shapes.  \nLet’s see an example of a polygon.  \n```python\nworld.loc["ALB", \'geometry\']\n```  \nNotice that it displayed the country of Albania.  \n```python' metadata={'Header 1': 'Boundaries represented as longitude/latitude'}page_content='x, y = world.loc["ALB", "geometry"].exterior.coords.xy' metadata={'Header 1': "Returns two arrays that hold the x and y coordinates of the points that define the polygon's exterior."}page_content='print(\'Points in the exterior of Albania:\', len(x))\n```  \nLet’s see another  \n```python\nworld.loc["AFG", "geometry"]\n```  \n```python' metadata={'Header 1': 'How many points?'}page_content='x, y = world.loc["AFG", \'geometry\'].exterior.coords.xy' metadata={'Header 1': "Returns two arrays that hold the x and y coordinates of the points that define the polygon's exterior."}page_content="print('Points in the exterior of Afghanistan:', len(x))\n```  \nNotice that we’ve now displayed Afghanistan.  \nThis is a more complex shape than Albania and thus required more points." metadata={'Header 1': 'How many points?'}page_content='```python\nfig, gax = plt.subplots(figsize=(10,10))' metadata={'Header 1': 'How many points?', 'Header 4': '2. Plotting the map'}page_content='world.query("continent == \'South America\'").plot(ax=gax, edgecolor=\'black\',color=\'lightblue\')' metadata={'Header 1': "By only plotting rows in which the continent is 'South America' we only plot SA."}page_content="gax.set_xlabel('longitude')\ngax.set_ylabel('latitude')  \ngax.spines['top'].set_visible(False)\ngax.spines['right'].set_visible(False)  \nplt.show()\n```  \nCreating this map may have been easier than you expected!  \nIn reality, a lot of heavy lifting is going on behind the scenes.  \nEntire university classes (and even majors!) focus on the theory and thought\nthat goes into creating maps, but, for now, we are happy to rely on the work done by the\nexperts behind `geopandas` and its related libraries." metadata={'Header 1': "By the way, if you haven't read the book 'longitude' by Dava Sobel, you should..."}page_content='In the code below, we run the same commands as before to plot the South American countries, but\n, now, we also plot the data in `gdf`, which contains the location of South American cities.  \n```python' metadata={'Header 1': "By the way, if you haven't read the book 'longitude' by Dava Sobel, you should...", 'Header 4': '3. Plot the cities'}page_content='fig, gax = plt.subplots(figsize=(10,10))' metadata={'Header 1': 'add a command to plot the cities'}page_content='world.query("continent == \'South America\'").plot(ax = gax, edgecolor=\'black\', color=\'white\')' metadata={'Header 1': 'South America.'}page_content="gdf.plot(ax=gax, color='red', alpha = 0.5)  \ngax.set_xlabel('longitude')\ngax.set_ylabel('latitude')\ngax.set_title('South America')  \ngax.spines['top'].set_visible(False)\ngax.spines['right'].set_visible(False)  \nplt.show()\n```  \n**Adding labels to points**.  \nFinally, we might want to consider annotating the cities so we know which cities are which.  \n```python" metadata={'Header 1': 'I want the cities as pale red dots.'}page_content='fig, gax = plt.subplots(figsize=(10,10))' metadata={'Header 1': 'We mostly use the code from before --- we still want the country borders plotted --- and we add a command to plot the cities'}page_content='world.query("continent == \'South America\'").plot(ax = gax, edgecolor=\'black\', color=\'white\')' metadata={'Header 1': "By only plotting rows in which the continent is 'South America' we only plot, well, South America."}page_content="gdf.plot(ax=gax, color='red', alpha = 0.5)  \ngax.set_xlabel('longitude')\ngax.set_ylabel('latitude')\ngax.set_title('South America')" metadata={'Header 1': 'cities as pale red dots.'}page_content="gax.spines['top'].set_visible(False)\ngax.spines['right'].set_visible(False)" metadata={'Header 1': 'Kill the spines...'}page_content="for x, y, label in zip(gdf['Coordinates'].x, gdf['Coordinates'].y, gdf['City']):\ngax.annotate(label, xy=(x,y), xytext=(4,4), textcoords='offset points')  \nplt.show()\n```" metadata={'Header 1': 'Label the cities'}page_content='In the example that follows, we will demonstrate how each county in Wisconsin voted during the 2016\nPresidential Election.  \nAlong the way, we will learn a couple of valuable lessons:  \n1. Where to find shape files for US states and counties\n1. How to match census style data to shape files  \n```python' metadata={'Header 1': 'Label the cities', 'Header 2': 'Case Study: Voting in Wisconsin'}page_content='foo = gpd.read_file("/home/chase/Downloads/tlgdb_2018_a_55_wi.gdb.zip")\n```  \n```python\nfoo["NAME"].str.split(" ").str[0].unique()\n```  \n```python\nfoo.shape\n```  \n```python\nfig, ax = plt.subplots(figsize=(10, 10))  \nfoo.plot(ax=ax)\n```' metadata={'Header 1': 'https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-geodatabase-file.html'}page_content='Our first step will be to find the border for the state of interest. This can be found on the [US\nCensus’s website here](https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html).  \nYou can download the `cb_2016_us_state_5m.zip` by hand, or simply allow `geopandas` to extract\nthe relevant information from the zip file online.  \n```python\nstate_df = gpd.read_file("https://datascience.quantecon.org/assets/data/cb_2016_us_state_5m.zip")\nstate_df.head()\n```  \n```python\nprint(state_df.columns)\n```  \n```python\nstate_df.query("NAME == \'New York\'")\n```  \nWe have various columns, but, most importantly, we can find the right geometry by filtering by name.  \n```python\nfig, gax = plt.subplots(figsize=(10, 10))\nstate_df.query("NAME == \'Wisconsin\'").plot(ax=gax, edgecolor="black", color="white")\nplt.show()\n```' metadata={'Header 1': 'https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-geodatabase-file.html', 'Header 3': 'Find and Plot State Border'}page_content='Next, we will add the county borders to our map.  \nThe county shape files (for the entire US) can be found on the [Census\nsite](https://www.census.gov/geo/maps-data/data/cbf/cbf_counties.html).  \nOnce again, we will use the 5m resolution.  \n```python\ncounty_df = gpd.read_file("https://datascience.quantecon.org/assets/data/cb_2016_us_county_5m.zip")\ncounty_df.head()\n```  \n```python\nprint(county_df.columns)\n```  \nWisconsin’s FIPS code is 55 so we will make sure that we only keep those counties.  \n```python\ncounty_df = county_df.query("STATEFP == \'55\'")\n```  \nNow we can plot all counties in Wisconsin.  \n```python\nfig, gax = plt.subplots(figsize=(10, 10))  \nstate_df.query("NAME == \'Wisconsin\'").plot(ax=gax, edgecolor="black", color="white")\ncounty_df.plot(ax=gax, edgecolor="black", color="white")  \nplt.show()\n```' metadata={'Header 1': 'https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-geodatabase-file.html', 'Header 3': 'Find and Plot County Borders'}page_content='The final step is to get the vote data, which can be found online on [this site](https://elections.wi.gov/elections-voting/results/2016/fall-general).  \nOur friend Kim says,  \n> Go ahead and open up the file. It’s a mess! I saved a cleaned up version of the file to\n`results.csv` which we can use to save the hassle with cleaning the data. For fun, you should\nload the raw data and try beating it into shape. That’s what you normally would have to do…\nand it’s fun.  \nWe’d like to add that such an exercise is also “good for you” (similar to how vegetables are good for you).  \nBut, for the example in class, we’ll simply start with his cleaned data.  \n```python\nresults = pd.read_csv("https://datascience.quantecon.org/assets/data/ruhl_cleaned_results.csv", thousands=",")\nresults.head()\n```  \n```python\nresults["county"].str.strip().str.title().values\n```  \n```python\ncounty_df["NAME"].str.title().unique()\n```  \nNotice that this is NOT a GeoDataFrame; it has no geographical information.  \nBut it does have the names of each county.  \nWe will be able to use this to match to the counties from `county_df`.  \nFirst, we need to finish up the data cleaning.  \n```python\nresults["county"] = results["county"].str.title()\nresults["county"] = results["county"].str.strip()\ncounty_df["NAME"] = county_df["NAME"].str.title()\ncounty_df["NAME"] = county_df["NAME"].str.strip()\n```  \nThen, we can merge election results with the county data.  \n```python\ncounty_df.shape\n```  \n```python\nres_w_states = county_df.merge(results, left_on="NAME", right_on="county", how="inner")\n```  \n```python\nres_w_states.shape\n```  \n```python\nres_w_states\n```  \nNext, we’ll create a new variable called `trump_share`, which will denote the percentage of votes that\nDonald Trump won during the election.  \n```python\nres_w_states["trump_share"] = res_w_states["trump"] / (res_w_states["total"])\nres_w_states["rel_trump_share"] = res_w_states["trump"] / (res_w_states["trump"]+res_w_states["clinton"])\nres_w_states.head()\n```  \nFinally, we can create our map.  \n```python\nfig, gax = plt.subplots(figsize = (10,8))' metadata={'Header 1': 'https://www.census.gov/geographies/mapping-files/time-series/geo/tiger-geodatabase-file.html', 'Header 3': 'Get Vote Data'}page_content="state_df[state_df['NAME'] == 'Wisconsin'].plot(ax = gax, edgecolor='black',color='white')" metadata={'Header 1': 'Plot the state'}page_content="res_w_states.plot(\nax=gax, edgecolor='black', column='rel_trump_share', legend=True, cmap='RdBu_r',\nvmin=0.2, vmax=0.8\n)" metadata={'Header 1': "Plot the counties and pass 'rel_trump_share' as the data to color"}page_content="gax.set_title('Republican vote share')" metadata={'Header 1': 'Add text to let people know what we are plotting'}page_content='plt.axis(\'off\')  \nplt.show()\n```  \nWhat do you see from this map?  \nHow many counties did Trump win? How many did Clinton win?  \n```python\nres_w_states.eval("trump > clinton").sum()\n```  \n```python\nres_w_states.eval("clinton > trump").sum()\n```  \nWho had more votes? Do you think a comparison in counties won or votes won is more reasonable? Why\ndo you think they diverge?  \n```python\nres_w_states["trump"].sum()\n```  \n```python\nres_w_states["clinton"].sum()\n```  \nWhat story could you tell about this divergence?  \n**Find counties within a certain distance of Madison**  \n```python\nmadison = Point(-89.4008, 43.0722)\n```  \n```python\ncounty_df.crs\n```  \n```python\ncounty_df.to_crs("ESRI:102008").crs\n```  \n```python\ncounty_df["geometry"].iloc[0].centroid.xy\n```  \n```python\n((-91.286 + 89.4008)**2 + (44.72 - 43.0722)**2)**0.5\n```  \n```python\nmadison = gpd.GeoDataFrame({"city": ["madison"], "latitude": [43.0722], "longitude": [-89.4008]})\nmadison["geometry"] = madison.apply(lambda x: Point(x["longitude"], x["latitude"]), axis=1)\nmadison.geometry.crs = "4269"\n```  \n```python\ncounty_df.loc[:, "within_50km_madison"] = (\ncounty_df\n["geometry"]\n.to_crs("ESRI:102008")\n.boundary\n.distance(\nmadison["geometry"].to_crs("ESRI:102008").iloc[0]\n) < 50_000\n)\n```  \n```python\ncounty_df.query("within_50km_madison")\n```  \n```python\nclose_counties = county_df.query("within_50km_madison")["NAME"]\n```  \n```python\nres_w_states["within_50km_madison"] = False\nres_w_states.loc[res_w_states["NAME"].isin(close_counties), "within_50km_madison"] = True\n```  \n```python\nres_w_states.groupby("within_50km_madison")["rel_trump_share"].mean()\n```' metadata={'Header 1': "I don't want the axis with long and lat"}page_content='Multiple Python libraries can help create interactive figures.  \nHere, we will see an example using bokeh.  \nIn the another lecture, we will see an example with folium.  \n```python\nfrom bokeh.io import output_notebook\nfrom bokeh.plotting import figure, ColumnDataSource\nfrom bokeh.io import output_notebook, show, output_file\nfrom bokeh.plotting import figure\nfrom bokeh.models import GeoJSONDataSource, LinearColorMapper, ColorBar, HoverTool\nfrom bokeh.palettes import brewer  \noutput_notebook()\nimport json\nres_w_states["clinton_share"] = res_w_states["clinton"] / res_w_states["total"]\n#Convert data to geojson for bokeh\nwi_geojson=GeoJSONDataSource(geojson=res_w_states.to_json())\n```  \n```python\ncolor_mapper = LinearColorMapper(palette = brewer[\'RdBu\'][10], low = 0, high = 1)\ncolor_bar = ColorBar(color_mapper=color_mapper, label_standoff=8,width = 500, height = 20,\nborder_line_color=None,location = (0,0), orientation = \'horizontal\')\nhover = HoverTool(tooltips = [ (\'County\',\'@county\'),(\'Portion Trump\', \'@trump_share\'),\n(\'Portion Clinton\',\'@clinton_share\'),\n(\'Total\',\'@total\')])\np = figure(title="Wisconsin Voting in 2016 Presidential Election", tools=[hover])\np.patches("xs","ys",source=wi_geojson,\nfill_color = {\'field\' :\'rel_trump_share\', \'transform\' : color_mapper})\np.add_layout(color_bar, \'below\')\nshow(p)\n```  \n```python  \n```' metadata={'Header 1': "I don't want the axis with long and lat", 'Header 3': 'Interactivity'}