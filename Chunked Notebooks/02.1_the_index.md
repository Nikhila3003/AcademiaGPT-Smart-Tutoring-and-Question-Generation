page_content='**Prerequisites**  \n- [Introduction to pandas](../p01_pandas_intro/v01_pandas_intro.ipynb)  \n**Outcomes**  \n- Understand how the index is used to align data\n- Know how to set and reset the index\n- Understand how to select subsets of data by slicing on index and columns\n- Understand that for DataFrames, the column names also align data' metadata={'Header 1': 'The Index'}page_content='- [The Index](#The-Index)\n- [So What is this Index?](#So-What-is-this-Index?)\n- [Setting the Index](#Setting-the-Index)\n- [Re-setting the Index](#Re-setting-the-Index)\n- [Choose the Index Carefully](#Choose-the-Index-Carefully)  \n```python\nimport pandas as pd\nimport numpy as np\n```' metadata={'Header 1': 'The Index', 'Header 2': 'Outline'}page_content='Every Series and DataFrame has an index  \nWe told you that the index was the “row labels” for the data  \nThis is true, but an index in pandas does much more than label the rows  \nThe purpose of this lecture is to understand the importance of the index  \nThe [pandas\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/dsintro.html)\nsays  \n> Data alignment is intrinsic. The link between labels and data will\nnot be broken unless done so explicitly by you.  \nIn practice, the index and column names are used to make sure the data is\nproperly aligned when operating on multiple DataFrames  \nThis is a somewhat abstract concept that is best understood by\nexample…  \nLet’s begin by loading some data on GDP components that we collected from\nthe World Bank’s World Development Indicators Dataset  \n```python\nurl = "https://datascience.quantecon.org/assets/data/wdi_data.csv"\ndf = pd.read_csv(url)\ndf.info()' metadata={'Header 1': 'The Index', 'Header 2': 'So What is this Index?'}page_content='df.head()\n```  \nWe’ll also extract a couple smaller DataFrames we can use in examples  \n```python\ndf_small = df.head(5)\ndf_small\n```  \n```python\ndf_tiny = df.iloc[[0, 3, 2, 4], :]\ndf_tiny\n```  \n```python\nim_ex = df_small[["Imports", "Exports"]]\nim_ex_copy = im_ex.copy()\nim_ex_copy\n```  \nObserve what happens when we evaluate `im_ex + im_ex_copy`  \n```python\nim_ex + im_ex_copy\n```  \nNotice that this operated *elementwise*, meaning that the `+`\noperation was applied to each element of `im_ex` and the corresponding\nelement of `im_ex_copy`  \nLet’s take a closer look at `df_tiny`:  \n```python\ndf_tiny\n```  \nRelative to `im_ex` notice a few things:  \n- The row labeled `1` appears in `im_ex` but not `df_tiny`\n- Some row labels appear in both, but they are not always in the same position\nwithin each DataFrame\n- Certain columns appear only in `df_tiny`\n- The `Imports` and `Exports` columns are the 6th and 5th columns of\n`df_tiny` and the 1st and 2nd of `im_ex`, respectively  \nNow, let’s see what happens when we try `df_tiny + im_ex`  \n```python\nim_ex_tiny = df_tiny + im_ex\nim_ex_tiny\n```  \nWhoa, a lot happened! Let’s break it down piece by piece!' metadata={'Header 1': 'Note data is in trillions USD'}page_content='For all (row, column) combinations that appear in both DataFrames (e.g.\nrows `[1, 3]` and columns `[Imports, Exports]`), the value of `im_ex_tiny`\nis equal to `df_tiny.loc[row, col] + im_ex.loc[row, col]`  \nThis happened even though the rows and columns were not in the same\norder  \nWe refer to this as pandas *aligning* the data for us  \nTo see how awesome this is, think about how to do something similar in\nExcel:  \n- `df_tiny` and `im_ex` would be in different sheets\n- The index and column names would be the first column and row in each\nsheet\n- We would have a third sheet to hold the sum\n- For each label in the first row and column of *either* the `df_tiny`\nsheet or the `im_ex` sheet we would have to do a `IFELSE` to check\nif the label exists in the other sheet and then a `VLOOKUP` to\nextract the value  \nIn pandas, this happens automatically, behind the scenes, and *very\nquickly*' metadata={'Header 1': 'Note data is in trillions USD', 'Header 3': 'Automatic Alignment'}page_content='```python\nim_ex_tiny = df_tiny + im_ex\nim_ex_tiny\n```  \nFor all elements in row `1` or columns\n`["country", "year", "GovExpend", "Consumption", "GDP"]`,\nthe value in `im_ex_tiny` is `NaN`  \nThis is how pandas represents *missing data*  \nWhen pandas was trying to look up the values in `df_tiny` and `im_ex`, it could\nonly find a value in one DataFrame: the other value was missing  \nWhen pandas tries to add a number to something that is missing, it says\nthat the result is missing (spelled `NaN`)  \n<a id=\'exercise-0\'></a>\n**Exercise 1**  \nWhat happens when you apply the `mean` method to `im_ex_tiny`?  \nIn particular, what happens to columns that have missing data? (HINT:\nalso looking at the output of the `sum` method might help)' metadata={'Header 1': 'Note data is in trillions USD', 'Header 3': 'Handling Missing Data'}page_content='For a DataFrame `df`, the `df.set_index` method allows us to use one\n(or more) of the DataFrame’s columns as the index.  \nHere’s an example.  \n```python\ndf_year = df.set_index(["year"])\ndf_year.head()\n```  \nNow that the year is on the index, we can use `.loc` to extract all the\ndata for a specific year.  \n```python\ndf_year.loc[2010]\n```  \nThis would be helpful, for example, if we wanted to compute the difference\nin the average of all our variables from one year to the next:  \n```python\ndf_year.loc[2009].mean() - df_year.loc[2008].mean()\n```  \nNotice that pandas did a few things for us.  \n- After computing `.mean()`, the index was set to the former column names\n- These column names were used to align data when we wanted asked pandas to\ncompute the difference  \nSuppose that someone asked you, “What was the GDP in the US in 2010?”  \nTo compute that statistic using `df_year` you might do something like this:  \n```python\ndf_year.loc[df_year["country"] == "United States", "GDP"].loc[2010]\n```  \nThat was a lot of work!  \nNow, suppose that after seeing you extract that data, your friend asks you\n“What about GDP in Germany and the UK in 2010?”  \nTo answer that question, you might write  \n```python\ndf_year.loc[df_year["country"].isin(["United Kingdom", "Germany"]), "GDP"].loc[2010]\n```  \nNotice that this code is similar to the code above, but now provides a result\nthat is ambiguous  \nThe two elements in the series both have with label 2010  \nHow do we know which is which?  \nWe might think that the first value corresponds to the United Kingdom because\nthat is what we listed first in the call to `isin`, but we would be wrong!  \nLet’s check.  \n```python\ndf_year.loc[2010]\n```  \nSetting just the year as the index has one more potential issue: we will\nget data alignment only on the year, which may not be sufficient  \nTo demonstrate this point, suppose now you are asked to use our WDI dataset\nto compute an approximation for net exports and investment in in 2009  \nAs a seasoned economist, you would remember the expenditure formula for GDP is\nwritten  \n$$\n\\text{GDP} = \\text{Consumption} + \\text{Investment} + \\text{GovExpend} + \\text{Net Exports}\n$$  \nwhich we can rearrange to compute investment as a function of the variables in\nour DataFrame…  \n$$\n\\text{Investment} = \\text{GDP} - \\text{Consumption} - \\text{GovExpend} - \\text{Net Exports}\n$$  \nNote that we can compute NetExports as `Exports - Imports`  \n```python\nnx = df_year["Exports"] - df_year["Imports"]\nnx.head(19)\n```  \nNow, suppose that we accidentally had a bug in our code that swapped\nthe data for Canada and Germany’s net exports in 2017.  \n>**Note**\n>\n>This example is contrived, but if you were getting unclean data from\nsome resource or doing more complicated operations, this type of mistake\nbecomes increasingly likely.  \n```python' metadata={'Header 1': 'Note data is in trillions USD', 'Header 2': 'Setting the Index'}page_content='ca17 = nx.iloc[[0]]\ng17 = nx.iloc[[18]]\nnx.iloc[[0]] = g17\nnx.iloc[[18]] = ca17  \nnx.head(19)\n```  \nNotice that if we now add `nx` to the DataFrame and compute investment\npandas doesn’t complain.  \n```python\ndf_year["NetExports"] = nx\ndf_year["Investment"] = df_year.eval("GDP - Consumption - GovExpend - NetExports")\ndf_year.loc[2017, :]\n```  \nBut, because we didn’t also have data alignment on the country, we would have overstated Canada’s investment by 281 billion USD and understated Germany’s by the\nsame amount.  \nTo make these types operation easier, we need to include both the year\nand country in the index…' metadata={'Header 1': 'do the swapping'}page_content='Including multiple columns in the index is advantageous in some situations  \nThese situations might include:  \n- When we need more than one piece of information (column) to identify an\nobservation (as in the Germany and UK GDP example above)\n- When we need data-alignment by more than one column  \nTo set multiple columns as the index, we pass a list of column\nnames to `set_index`  \n```python\nwdi = df.set_index(["country", "year"])\nwdi.head(20)\n```  \nNotice that in the display above, the row labels seem to have two\n*levels* now.  \nThe *outer* (or left-most) level is named `country` and the *inner* (or\nright-most) level is named `year`.  \nWhen a DataFrame’s index has multiple levels, we (and the pandas documentation)\nrefer to the DataFrame as having a **hierarchical index**' metadata={'Header 1': 'do the swapping', 'Header 3': 'Setting a Hierarchical Index'}page_content='Now, we can answer our friend’s questions in a much more straightforward way  \n```python\nwdi.loc[("United States", 2010), "GDP"]\n```  \n```python\nwdi.loc[(["United Kingdom", "Germany"], 2010), "GDP"]\n```  \nAs shown above, we can use `wdi.loc` to extract different slices of our\nnational accounts data  \nThe rules for using `.loc` with a hierarchically-indexed DataFrame are\nsimilar to the ones we’ve learned for standard DataFrames, but they are a bit\nmore elaborate as we now have more structure to our data  \nWe will summarize the main rules, and then work through an exercise that\ndemonstrates each of them  \n**Slicing rules**  \nWhen slicing data, using `list`s and `tuple`s lead to different results  \nA `tuple` in row slicing will be used to denote a single hierarchical\nindex and must include a value for each level  \n**Example**: `("United States", 2010)` in `wdi.loc[("United States", 2010), "GDP"]`  \n`list` in row slicing will be an “or” operation, where it chooses rows\nbased on whether the index value corresponds to *any* element of the list (e.g. `["United Kingdom", "Germany"]` above)  \n**Example**: `["United Kingdom", "Germany"]` in `wdi.loc[(["United Kingdom", "Germany"], 2010), "GDP"]` above  \n**Row slicing examples**  \n**1** `wdi.loc["United States"]`: all rows where the *outer* most index value is\nequal to `United States`  \n**2** `wdi.loc[("United States", 2010)]`: all rows where the *outer-most* index value\nis equal to `"United States` and the second level is equal to `2010`  \n**3** `wdi.loc[["United States", "Canada"]]`: all rows where the *outer-most* index is\neither `"United States"` or `"Canada"`  \n**4** `wdi.loc[(["United States", "Canada"], [2010, 2011]), :]`: all rows where the\n*outer-most* index is either `"United States` or `"Canada"` AND where the\nsecond level index is either `2010` or `2011`  \n**5** `wdi.loc[[("United States", 2010), ("Canada", 2011)], :]`: all rows where the the\ntwo hierarchical indices are either `("United States", 2010)` or\n`("Canada", 2011)`  \nWe can also restrict `.loc` to extract certain columns by doing:  \n1. `wdi.loc[rows, "GDP"]`: return the rows specified by rows (see rules\nabove) and only column named `GDP` (returned object will be a\nSeries)\n1. `df.loc[rows, ["GDP", "Consumption"]]`: return the rows specified by rows\n(see rules above) and only columns `GDP` and `Consumption`  \n<a id=\'exercise-1\'></a>\n**Exercise 2**  \nFor each of the examples below do the following:  \n- Determine which of the rules above applies\n- Identify the `type` of the returned value\n- Explain why the slicing operation returned the data it did  \nWrite your answers  \n```python\nwdi.loc[["United States", "Canada"]]\n```  \n```python\nwdi.loc[(["United States", "Canada"], [2010, 2011, 2012]), :]\n```  \n```python\nwdi.loc["United States"]\n```  \n```python\nwdi.loc[("United States", 2010), ["GDP", "Exports"]]\n```  \n```python\nwdi.loc[("United States", 2010)]\n```  \n```python\nwdi.loc[[("United States", 2010), ("Canada", 2015)]]\n```  \n```python\nwdi.loc[["United States", "Canada"], "GDP"]\n```  \n```python\nwdi.loc["United States", "GDP"]\n```' metadata={'Header 1': 'do the swapping', 'Header 3': 'Slicing a Hierarchical Index'}page_content="The data alignment features we talked about above also apply to a\n`MultiIndex` DataFrame  \nThe following exercise gives you a chance to experiment with this  \n<a id='exercise-2'></a>\n**Exercise 3**  \nTry setting `my_df` to some subset of the rows in `wdi` (use one of the\n`.loc` variations above)  \nThen see what happens when you do `wdi / my_df` or `my_df ** wdi`  \nTry changing the subset of rows in `my_df` and repeat until you\nunderstand what is happening" metadata={'Header 1': 'do the swapping', 'Header 3': 'Alignment with `MultiIndex`'}page_content='When we want to extract rows for a few values of the outer index and all\nvalues for an inner index level, we can use the convenient\n`df.loc[[id11, id22]]` shorthand  \nFor example, we can use this notation to extract all the data for the United States and\nCanada:  \n```python\nwdi.loc[["United States", "Canada"]]\n```  \nHowever, suppose we wanted to extract the data for all countries, but only the\nyears 2005, 2007, and 2009  \nWe cannot do this with what we know about `wdi.loc` because the year is on the second level,\nnot outer-most level of our index  \nTo get around this limitation, we can use the `pd.IndexSlice` helper  \nHere’s an example  \n```python\nwdi.loc[pd.IndexSlice[:, [2005, 2007, 2009]], :]\n```  \nNotice that the `:` in the first part of `[:, ["A", "D"]]`\ninstructed pandas to give us rows for all values of the outer most index\nlevel  \nThe `:` just before the final `]` said grab all the columns  \n<a id=\'exercise-3\'></a>\n**Exercise 4**  \nBelow, we create `wdi2`, which is the same as `wdi` except that the\nlevels of the index are swapped  \nIn the cells after `df6` is defined, we have commented out\na few of the slicing examples from the previous exercise  \nFor each of these examples, use `pd.IndexSlice` to extract the same\ndata from `df6`  \n(HINT: You will need to *swap* the order of the row slicing arguments\nwithin the `pd.IndexSlice`)  \n```python\nwdi2 = df.set_index(["year", "country"])\n```  \n```python' metadata={'Header 1': 'do the swapping', 'Header 3': '`pd.IndexSlice`'}page_content='```  \n```python' metadata={'Header 1': 'wdi.loc["United States"]'}page_content='```  \n```python' metadata={'Header 1': 'wdi.loc[(["United States", "Canada"], [2010, 2011, 2012]), :]'}page_content='```' metadata={'Header 1': 'wdi.loc[["United States", "Canada"], "GDP"]'}page_content='The functionality of `MultiIndex` also applies to the column labels  \nLet’s see how it works  \n```python\nwdiT = wdi.T  # .T means "transpose" or "swap rows and columns"\nwdiT\n```  \nNotice that `wdiT` seems to have two levels of names for the columns  \nThe same logic laid out in the above row slicing rules applies when we\nhave a hierarchical index for column names  \n```python\nwdiT.loc[:, "United States"]\n```  \n```python\nwdiT.loc[:, ["United States", "Canada"]]\n```  \n```python\nwdiT.loc[:, (["United States", "Canada"], 2010)]\n```  \n<a id=\'exercise-4\'></a>\n**Exercise 5**  \nUse `pd.IndexSlice` to extract all data from `wdiT` where the `year`\nlevel of the column names (the second level) is one of 2010, 2012, and 2014' metadata={'Header 1': 'wdi.loc[["United States", "Canada"], "GDP"]', 'Header 3': 'Multi-index Columns'}page_content="The `df.reset_index` method will move one or more level of the index\nback into the DataFrame as a normal column  \nWith no additional arguments, it moves all levels out of the index and\nsets the index of the returned DataFrame to the default of\n`range(df.shape[0])`  \n```python\nwdi.reset_index()\n```  \n<a id='exercise-5'></a>\n**Exercise 6**  \nLook up the documentation for the `reset_index` method and study it to\nlearn how to do the following:  \n- Move just the `year` level of the index back as a column\n- Completely throw away all levels of the index\n- Remove the `country` of the index and *do not* keep it as a column  \n```python" metadata={'Header 1': 'wdi.loc[["United States", "Canada"], "GDP"]', 'Header 2': 'Re-setting the Index'}page_content='```  \n```python' metadata={'Header 1': 'remove just year level and add as column'}page_content='```  \n```python' metadata={'Header 1': 'throw away all levels of index'}page_content='```' metadata={'Header 1': "Remove country from the index -- don't keep it as a column"}page_content='So, now that we know that we use index and column names for\naligning data, “how should we pick the index?” is a natural question to ask  \nTo guide us to the right answer, we will list the first two components\nto [Hadley Wickham’s](http://hadley.nz/) description of [tidy\ndata](http://vita.had.co.nz/papers/tidy-data.html):  \n1. Each column should each have one variable\n1. Each row should each have one observation  \nIf we strive to have our data in a tidy form (we should), then when\nchoosing the index, we should set:  \n- the row labels (index) to be a unique identifier for an observation\nof data\n- the column names to identify one variable  \nFor example, suppose we are looking data on interest rates  \nEach column might represent one bond or asset and each row might\nrepresent the date  \nUsing hierarchical row and/or column indices allows us to store higher\ndimensional data in our (inherently) two dimensional DataFrame' metadata={'Header 1': "Remove country from the index -- don't keep it as a column", 'Header 2': 'Choose the Index Carefully'}page_content='The correct column(s) to choose for the index often depends on the context of\nyour analysis  \nFor example, if I were studying how GDP and consumption evolved over time for\nvarious countries, I would want time (year) and country name on the index  \nOn the other hand, if I were trying to look at the differences across countries\nand variables within a particular year, I may opt to put the country and\nvariable on the index and have years be columns  \nFollowing the tidy data rules above and thinking about how you intend to *use*\nthe data – and a little practice – will enable you to consistently select the\ncorrect index' metadata={'Header 1': "Remove country from the index -- don't keep it as a column", 'Header 2': 'Choose the Index Carefully', 'Header 3': 'Know Your Goal'}