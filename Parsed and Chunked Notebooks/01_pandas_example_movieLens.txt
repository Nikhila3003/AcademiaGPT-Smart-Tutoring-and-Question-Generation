[[{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '\n# Pandas Example: MovieLens Data\n\n**Outcomes**\n\n- Learn how to download file from internet using the [requests](https://requests.readthedocs.io/en/master/) library\n- Know how to operate on a `.zip` file in memory, without writing to hard drive\n- Practice merging datasets'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '**Note: requires internet access to run.**  \n\nThis Jupyter notebook was originally created in 2016 by Dave Backus, Chase Coleman, Brian LeBlanc, and Spencer Lyon for the NYU Stern course [Data Bootcamp](http://databootcamp.nyuecon.com/).\n\nThe notebook has been modified for this course'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}, 'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': '%matplotlib inline \n\nimport pandas as pd             # data package\nimport matplotlib.pyplot as plt # graphics \nimport datetime as dt           # date tools, used to note current date  \n\n# these are new \nimport os                       # operating system tools (check files)\nimport requests, io             # internet and input tools  \nimport zipfile as zf            # zip file tools \nimport shutil                   # file management tools'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## MovieLens data \n\nThe [GroupLens](https://grouplens.org/) team at the University of Minnesota has prepared many datasets\n\nOne is called [MovieLens](https://grouplens.org/datasets/movielens/), and contains millions of movie ratings by viewers and users of the MovieLens website\n\nWe will use a small subset of the data with 100,000 ratings'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'This data comes in a `.zip` file that contains a handful of csv\'s and a readme\n\nHere are some details about the zipped files:\n\n* `ratings.csv`:  each line is an individual film rating with the rater and movie id\'s and the rating.  Order:  `userId, movieId, rating, timestamp`. \n* `tags.csv`:  each line is a tag on a specific film.  Order:  `userId, movieId, tag, timestamp`. \n* `movies.csv`:  each line is a movie name, its id, and its genre.  Order:  `movieId, title, genres`.  Multiple genres are separated by "pipes" `|`.   \n* `links.csv`:  each line contains the movie id and corresponding id\'s at [IMBd](http://www.imdb.com/) and [TMDb](https://www.themoviedb.org/).  '}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'We are interested in the `ratings.csv` and `movies.csv` files as pandas DataFrames\n\nThere are at least two approaches to doing this:\n\n1. Download the file to the hard drive, unzip manually, then come back and use `pd.read_csv`\n2. Have Python download the file, learn to use Python to handle zip files, then use `pd.read_csv`\n\nThe first option is likely easier, but the second is more powerful\n\nWe will choose option 2 here as it gives us a chance to learn more "real-world" data+Python skills'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "**Why do it the hard way?**\n\n- It builds character\n- Entire analysis can be self-contained in our notebook, no external *by hand* steps  needed\n- Can be applied to other datasets, as we'll surely see a zip file again in the future"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': "## Automated file download \n\n**WANT:** create pandas DataFrames from the `ratings.csv` and `movies.csv` files in the zipfile on the GroupLens website\n\nLet's unpack what steps need to happen:\n\n1. Download the file: we'll use the [requests](http://docs.python-requests.org/) package\n2. Unpack raw downloaded content as file: using built-in [io](https://docs.python.org/3.5/library/io.html) module's `io.BytesIO`\n3. Access csv files inside the zip file: using built-in [zipfile](https://docs.python.org/3.5/library/zipfile.html) module to read csv's from zip\n4. Read in csvs: easy part -- using `pd.read_csv`"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### Digression 1\n\nThe `requests` documentation states\n\n>Recreational use of other HTTP libraries may result in dangerous side-effects, including: security vulnerabilities, verbose code, reinventing the wheel, constantly reading documentation, depression, headaches, or even death.\n\nWe whole-heartedly agree'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### Digression 2\n\nWe found this [Stack Overflow exchange](http://stackoverflow.com/questions/23419322/download-a-zip-file-and-extract-it-in-memory-using-python3) helpful when creating this solution'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "### Step 1: Download the file\n\nLet's get to it!\n\nHere we download the file and print out some information about the response object"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}}, 'outputs': [], 'source': "#  Step 1 -- download the file \nurl = 'http://files.grouplens.org/datasets/movielens/ml-latest-small.zip'\nres = requests.get(url) \n\n# (sub-step, see what the response looks like)\nprint('Response status code:', res.status_code)\nprint('Response type:', type(res))\nprint('Response .content:', type(res.content)) \nprint('Response headers:\\n', res.headers, sep='')"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "### Step 2: read file as bytes\n\nThe ZipFile is a binary file format (not plain text)\n\nFor this reason we need to treat the contents of the file as bytes\n\nWe'll load in `res.content` into an instance of `io.BytesIO"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}, 'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': '# Step 2 -- read bytes of response contentonvert bytes to zip file  \nbytes = io.BytesIO(res.content)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### Step 3: Interpret bytes as ZipFile\n\nNow we have downloaded file, and interpreted as a binary source (`BytesIO`)\n\nThis is not just any binary file, but rather a zip compressed file\n\nPython knows how to handle these using the built-in `zipfile` module\n\nBelow we tell Python to interpret the `BytesIO` as a ZipFile'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}, 'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': "# Step 3 -- Interpret bytes as zipfile\nzip = zf.ZipFile(bytes)\nprint('Type of zipfile object:', type(zip))"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "Now that we have a ZipFile, we need to explore what is inside\n\nThe `ZipFile` class has a handy method named `namelist` \n\nThis method lists all folders and files in the zip archive\n\nLet's take a look"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}}, 'outputs': [], 'source': '# (sub-step, inspect the file)\nnames = zip.namelist()\nnames'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'Notice that our target `ratings.csv` and `movies.csv` files are there\n\nHowever, they are in a folder named `ml-latest-small`\n\nWe could write out the "path" to those files by hand, but instead we\'ll let Python find them for us'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': 'movie_fn = [n for n in names if "movies" in n][0]\nratings_fn = [n for n in names if "ratings" in n][0]\n\nprint("The path to movies.csv is:", movie_fn)'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "### Step 4: `pd.read_csv` the Files\n\nNow that we have the ZipFile **and** the path to our csvs, let's read them in as DataFrames\n\nFor this we'll use our friend `pd.read_csv`\n\nWe need to call the `.open` method on our zipfile\n\nThis method expects the path to the file we need to open, these are saved in `movie_fn` and `ratings_fn` above"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': "# extract and read csv's\nmovies  = pd.read_csv(zip.open(movie_fn))\nratings = pd.read_csv(zip.open(ratings_fn))"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "Let's take a look at the data"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}, 'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': 'movies.info()\nmovies.head(3)'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': 'ratings.info()\nratings.head(3)'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': "## Data Organization\n\nThe movie ratings in the dataframe `ratings` give us individual opinions about movies, but they don't include the name of the movie.  \n\n**Why not?**"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### Normalization\n\nStoring movie names in rating DataFrame would cause movie name to be repeated many times\n\nThe string "Grumpier Old Men (1995)" takes up more space in a file than the integer `3`\n\nSo, the GroupLens team decided to store the movie name in `movies.csv`, and a `movidId` column that is an integer\n\nIn other files, they can use just the `movieId` column\n\nThis is an eample of a relational database (think SQL) technique known as [normalization](https://en.wikipedia.org/wiki/Database_normalization)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "**Why normalize?**\n\nThere are many benefits to normalization, but two that immediately come to mind are:\n\n1. Save storage space: movie title (and genres in this example) are not repeated for each rating\n2. Easier to maintain/update\n\nFor the second point, suppose the GroupLens team wanted to include the movie's director\n\nIn the current, normalized format they would add a `director` column to `movies.csv` and have one row to update per movie\n\nIf they instead chose to put the movie title inside the `ratings.csv` they would have to find all occurances of each movie and add the director"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## Combining ratings and movies\n\nWe **want** to be able to analyze the ratings for movies, and associate those ratings with a movie name\n\nWe need a way to bring in the movie title information into the `ratings` DataFrame\n\nThis is a perfect use case for `merge`!'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "Let's start with a small example, just the first three rows of ratings:\n\nHere's what this looks like"}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}}, 'outputs': [], 'source': 'ratings.head(3)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "Now let's see what happens when we `merge` this with the `movies` DataFrame"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': 'ratings.head(3).merge(movies, on="movieId")'}, {'cell_type': 'markdown', 'metadata': {}, 'source': "Here's a breakdown of what happened:\n\n- For each row in `ratings.head(3)` pandas found the `movieId`\n- It then looked for row(s) in `movies` that had a matching `movieId`\n- It then added columns `title` and `genres` alongside existing columns from `ratings` (`userId`, `rating`, `timestamp`) to form combined DataFrame"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "Let's now apply this `merge` to the whole `ratings` dataset"}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}}, 'outputs': [], 'source': "combo = pd.merge(ratings, movies,   # left and right df's\n                 how='left',        # add to left \n                 on='movieId'       # link with this variable/column \n                ) \n\nprint('Dimensions of ratings:', ratings.shape)\nprint('Dimensions of movies:', movies.shape)\nprint('Dimensions of new df:', combo.shape)\n\ncombo.head(20)"}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': "**Exercise.** Some of these we know how to do, the others we don't.  For the ones we know, what is the answer?  For the others, what (in loose terms) do we need to be able to do to come up with an answer?  \n\n* What is the overall average rating?  \n* What is the overall distribution of ratings?  \n* What is the average rating of each movie?  \n* How many ratings does each movie get?  "}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': "# Your code/idea here -- average rating\ncombo['rating'].mean()"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': "# Your code/idea here -- distribution of ratings\nfig, ax = plt.subplots()\nbins = [bin/100 for bin in list(range(25, 550, 50))]\nprint(bins)\ncombo['rating'].plot(kind='hist', ax=ax, bins=bins, color='blue', alpha=0.5)\nax.set_xlim(0,5.5)\nax.set_ylabel('Number')\nax.set_xlabel('Rating')\nplt.show()\n\n"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': "import plotly.graph_objects as go \n\ntrace = go.Histogram(\n    x=combo['rating'],\n    name='control',\n    autobinx=False,\n    xbins=dict(\n        start=.5,\n        end=5.0,\n        size=0.5\n    ),\n    marker_color='Blue',\n    opacity=0.75\n)\n\nlayout = go.Layout(\n    title='Distribution of ratings',\n    xaxis_title='Rating value',\n    yaxis_title='Count',\n    bargap=0.01,\n    bargroupgap=0.1,\n)\n\nfig = go.Figure(data=[trace], layout=layout)\nfig.show()"}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': "# Your code/idea here -- average rating of each movie\n\n# average for a specific movie \ncombo[combo['movieId']==31]['rating'].mean()"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': "%%time\n# average for all movies (spoiler we will learn this next time!!)\nave_mov = combo['rating'].groupby(combo['movieId']).mean()\nave_mov.reset_index() "}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'outputs': [], 'source': "# Your code/idea here -- number of ratings for each movie\n\n# number of ratings for a single movie\ncombo[combo['movieId']==31]['rating'].count()"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'collapsed': False, 'jupyter': {'outputs_hidden': False}}, 'outputs': [], 'source': "# number of ratings for all movies (another spoiler!)\ncombo['rating'].groupby(combo['movieId']).count().reset_index()"}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## Resources \n\nThe [Pandas docs](http://pandas.pydata.org/pandas-docs/stable/merging.html) are ok, but we prefer the Data Carpentry [guide](http://www.datacarpentry.org/python-ecology-lesson/04-merging-data)'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': ''}]]