[[{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '# Reshape\n\n**Prerequisites**\n\n- [Intro](../p01_pandas_intro/v01_pandas_intro.ipynb)  \n- [pandas basics](../p01_pandas_intro/v02_pandas_basics.ipynb)  \n- [Importance of index](../p02_organizing_data_with_pandas_1/01_the_index.ipynb)  \n\n\n**Outcomes**\n\n- Understand tidy data  \n- Understand and be able to apply the `melt`/`stack`/`unstack`/`pivot` methods  \n- Practice transformations of indices  '}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'import numpy as np\nimport pandas as pd\n\n%matplotlib inline'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '## Outline\n\n- [Reshape](#Reshape)  \n  - [Tidy Data](#Tidy-Data)  \n  - [Reshaping your Data](#Reshaping-your-Data)  \n  - [Long vs Wide](#Long-vs-Wide)  \n  - [`set_index`, `reset_index`, and Transpose](#`set_index`,-`reset_index`,-and-Transpose)  \n  - [`stack` and `unstack`](#`stack`-and-`unstack`)  \n  - [`melt`](#`melt`)  \n  - [`pivot` and `pivot_table`](#`pivot`-and-`pivot_table`)  \n  - [Visualizing Reshaping](#Visualizing-Reshaping)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## Tidy Data\n\nWhile pushed more generally in the `R` language, the concept of “[tidy data](https://en.wikipedia.org/wiki/Tidy_data)” is helpful in understanding the\nobjectives for reshaping data, which in turn makes advanced features like\n[GroupBy](groupby.ipynb) more seamless.\n\nHadley Wickham gives a terminology slightly better-adapted for the experimental\nsciences, but nevertheless useful for the social sciences.\n\n> A dataset is a collection of values, usually either numbers (if\nquantitative) or strings (if qualitative). Values are organized in two\nways. Every value belongs to a variable and an observation. A variable\ncontains all values that measure the same underlying attribute (like\nheight, temperature, duration) across units. An observation contains all\nvalues measured on the same unit (like a person, or a day, or a race)\nacross attributes. – [Tidy Data (Journal of Statistical Software 2013)](https://www.jstatsoft.org/index.php/jss/article/view/v059i10/v59i10.pdf)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'With this framing,\n\n> A dataset is messy or tidy depending on how rows, columns and tables are\nmatched with observations, variables, and types. In tidy data:\n1.  Each variable forms a column.\n2.  Each observation forms a row.\n3.  Each type of observational unit forms a table.\n\nThe “column” and “row” terms map directly to pandas columns and rows, while the\n“table” maps to a pandas DataFrame.'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'The question that should come to mind anytime you\'re introduced to a dataset is, "What uniquely identifies an “observation” in your data?"\n\nIs it a country? A year? A combination of country and year?\n\nThese will become the indices of your DataFrame.\n\nThe concept of an "observation" may  not be unique to a dataset. For example, consider a time-series of county level GDP data.\n\n* The most "pure" form of tidy data would probably classify the year/country as the identifier and have a single variable of GDP\n* You could also consider the year to be the unique identifier and have each country\'s GDP be the variable\n* Or, a variable might even be the GDP in a given year with the countries being the unique identifiers\n\nWhat you consider to be an observation will depend on the question you\'re asking.'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## Reshaping your Data\n\nThe data you receive is not always in a “shape” that makes it easy to analyze.\n\nWhat do we mean by shape? The number of rows and columns in a\nDataFrame and how information is stored in the index and column names.\n\nThis lecture will teach you the basic concepts of reshaping data.\n\nAs with other topics, we recommend reviewing the [pandas\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/reshaping.html)\non this subject for additional information.\n\nWe will keep our discussion here as brief and simple as possible because\nthese tools will reappear in subsequent lectures.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'url = "https://datascience.quantecon.org/assets/data/bball.csv"\nbball = pd.read_csv(url)\nbball.info()\n\nbball'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## Long vs Wide\n\nMany of the operations discussed change between long and wide DataFrames.\n\nWhat does it mean for a DataFrame to be long or wide?\n\nHere is long possible long-form representation of our basketball data.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# Don\'t worry about what this command does -- We\'ll see it soon\nbball_long = bball.melt(id_vars=["Year", "Player", "Team", "TeamName"])\n\nbball_long'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'And here is a wide-form version.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# Again, don\'t worry about this command... We\'ll see it soon too\nbball_wide = bball_long.pivot_table(\n    index="Year",\n    columns=["Player", "variable", "Team"],\n    values="value"\n)\nbball_wide'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## `set_index`, `reset_index`, and Transpose\n\nWe have already seen a few basic methods for reshaping a\nDataFrame.\n\n- `set_index`: Move one or more columns into the index.  \n- `reset_index`: Move one or more index levels out of the index and make\n  them either columns or drop from DataFrame.  \n- `T`: Swap row and column labels.  \n\n\nSometimes, the simplest approach is the right approach.\n\nLet’s review them briefly.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball2 = bball.set_index(["Player", "Year"])\nbball2.head()'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'scrolled': True, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball3 = bball2.T\nbball3.head()'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## `stack` and `unstack`\n\nThe `stack` and `unstack` methods operate directly on the index\nand/or column labels.'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### `stack`\n\n`stack` is used to move certain levels of the column labels into the\nindex (i.e. moving from wide to long)\n\nLet’s take `ball_wide` as an example.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball_wide'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'Suppose that we want to be able to use the `mean` method to compute the\naverage value of each stat for each player, regardless of year or team.\n\nTo do that, we need two column levels: one for the player and one for the variable.\n\nWe can achieve this using the `stack` method.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball_wide.stack()'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Now, we can compute the statistic we are after.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'player_stats = bball_wide.stack().mean()\nplayer_stats'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Now suppose instead of that we wanted to compute the average for each team and\nstat, averaging over years and players.\n\nWe’d need to move the `Player` level down into the index so we are\nleft with column levels for Team and variable.\n\nWe can ask pandas do this using the `level` keyword argument.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball_wide.stack(level="Player")'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'Now we can compute the mean.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball_wide.stack(level="Player").mean()'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Notice a few features of the `stack` method:\n\n- Without any arguments, the `stack` arguments move the level of column\n  labels closest to the data (also called inner-most or bottom level of labels)\n  to become the index level closest to the data (also called the inner-most or\n  right-most level of the index). In our example, this moved `Team` down from\n  columns to the index.  \n- When we do pass a level, that level of column labels is moved down to the\n  right-most level of the index and all other column labels stay in their\n  relative position.  \n\n\nNote that we can also move multiple levels at a time in one call to `stack`.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball_wide.stack(level=["Player", "Team"])'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': '-'}}, 'source': 'In the example above, we started with one level on the index (just the year) and\nstacked two levels to end up with a three-level index.\n\nNotice that the two new index levels went closer to the data than the existing\nlevel and that their order matched the order we passed in our list argument to\n`level`.'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '### `unstack`\n\nNow suppose that we wanted to see a bar chart of each player’s stats.\n\nThis chart should have one “section” for each player and a different colored\nbar for each variable.\n\nAs we’ll learn in more detail in a later lecture,  we will\nneed to have the player’s name on the index and the variables as columns to do this.\n\n>**Note**\n>\n>In general, for a DataFrame, calling the `plot` method will put the index\non the horizontal (x) axis and make a new line/bar/etc. for each column.\n\nNotice that we are close to that with the `player_stats` variable.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'player_stats'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'We now need to rotate the variable level of the index up to be column layers.\n\nWe use the `unstack` method for this.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'player_stats.unstack()'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'And we can make our plot!'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'player_stats.unstack().plot.bar()'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'This particular visualization would be helpful if we wanted to see which stats\nfor which each player is strongest.\n\nFor example, we can see that Steph Curry scores far more points than he does\nrebound, but Serge Ibaka is a bit more balanced.\n\nWhat if we wanted to be able to compare all players for each statistic?\n\nThis would be easier to do if the bars were grouped by variable, with a\ndifferent bar for each player.\n\nTo plot this, we need to have the variables on the index and the player\nname as column names.\n\nWe can get this DataFrame by setting `level="Player"` when calling `unstack`.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'player_stats.unstack(level="Player")'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'player_stats.unstack(level="Player").plot.bar()'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Now we can use the chart to make a number of statements about players:\n\n- Ibaka does not get many assists, compared to Curry and Durant.  \n- Steph and Kevin Durant are both high scorers.  \n\n\nBased on the examples above, notice a few things about `unstack`:\n\n- It is the *inverse* of `stack`; `stack` will move labels down\n  from columns to index, while `unstack` moves them up from index to columns.  \n- By default, `unstack` will move the level of the index closest to the data\n  and place it in the column labels closest to the data.  \n\n\n>**Note**\n>\n>Just as we can pass multiple levels to `stack`, we can also pass multiple\nlevels to `unstack`.\n'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '### Summary\n\nIn some ways `set_index`, `reset_index`, `stack`, and `unstack`\nare the “most fundamental” reshaping operations…\n\nThe other operations we discuss can be formulated with these\nfour operations (and, in fact, some of them are exactly written as these\noperations in `pandas`’s code base).\n\n*Pro tip*: We remember stack vs unstack with a mnemonic: **U**nstack moves index\nlevels **U**p'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## `melt`\n\nThe `melt` method is used to move from wide to long form.\n\nIt can be used to move all of the “values” stored in your DataFrame to a\nsingle column with all other columns being used to contain identifying\ninformation.\n\n**Warning**: When you use `melt`, any index that you currently have\nwill be deleted.\n\nWe saw used `melt` above when we constructed `bball_long`:'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# this is how we made ``bball_long``\nbball.melt(id_vars=["Year", "Player", "Team", "TeamName"])]]'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': '-'}}, 'source': 'Notice that the columns we specified as `id_vars` remained columns, but all\nother columns were put into two new columns:\n\n1. `variable`: This has dtype string and contains the former column names.\n  as values  \n1. `value`: This has the former values.  \n\n\nUsing this method is an effective way to get our data in *tidy* form as noted\nabove.'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '**Exercise 2**\n\n- What do you think would happen if we wrote `bball.melt(id_vars=["Year", "Player"])`\n  rather than `bball.melt(id_vars=["Year", "Player", "Team", "TeamName"])`?\n  Were you right? Write your thoughts.  \n- Read the documentation and focus on the argument `value_vars`. How\n  does `bball.melt(id_vars=["Year", "Player"], value_vars=["Pts", "Rebound"])`\n  differ from `bball.melt(id_vars=["Year", "Player"])`?  \n- Consider the differences between `bball.stack` and `bball.melt`.\n  Is there a way to make them generate the same output?\n  (Hint: you might need to use both `stack` and another method from\n  above)? Write your thoughts.  '}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': '-'}}, 'source': ''}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': ''}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': ''}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## `pivot` and `pivot_table`\n\nThe next two reshaping methods that we will use are closely related.\n\nSome of you might even already be familiar with these ideas because you\nhave previously used *pivot tables* in Excel.\n\n- If so, good news. We think this is even more powerful than Excel\n  and easier to use!  \n- If not, good news. You are about to learn a very powerful and user-friendly tool.  \n\n\nWe will begin with `pivot`.\n\nThe `pivot` method:\n\n- Takes the unique values of one column and places them along the index.  \n- Takes the unique values of another column and places them along the\n  columns.  \n- Takes the values that correspond to a third column and fills in the\n  DataFrame values that correspond to that index/column pair.  \n\n\nWe’ll illustrate with an example.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# .head 8 excludes Ibaka -- will discuss why later\nbball.head(6).pivot(index="Year", columns="Player", values="Pts")'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'fragment'}}, 'source': 'We can replicate `pivot` using three of the fundamental operations\nfrom above:\n\n1. Call `set_index` with the `index` and `columns` arguments  \n1. Extract the `values` column  \n1. `unstack` the columns level of the new index  '}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '#  1---------------------------------------  2---  3----------------------\nbball.head(6).set_index(["Year", "Player"])["Pts"].unstack(level="Player")'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'One important thing to be aware of is that in order for `pivot` to\nwork, the index/column pairs must be *unique*!\n\nBelow, we demonstrate the error that occurs when they are not unique.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# Ibaka shows up twice in 2016 because he was traded mid-season from\n# the Orlando Magic to the Toronto Raptors\nbball.pivot(index="Year", columns="Player", values="Pts")\n'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### `pivot_table`\n\nThe `pivot_table` method is a generalization of `pivot`.\n\nIt overcomes two limitations of `pivot`:\n\n1. It allows you to choose multiple columns for the index/columns/values\n  arguments.  \n1. It allows you to deal with duplicate entries by\n  having you choose how to combine them.  '}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Notice that we can replicate the functionality of `pivot` if we pass\nthe same arguments.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball.head(6).pivot_table(index="Year", columns="Player", values="Pts")'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'But we can also choose multiple columns to be used in\nindex/columns/values.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball.pivot_table(index=["Year", "Team"], columns="Player", values="Pts")'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball.pivot_table(index="Year", columns=["Player", "Team"], values="Pts")'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'AND we can deal with duplicated index/column pairs.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# This produced an error\n# bball.pivot(index="Year", columns="Player", values="Pts")\n\n# This doesn\'t!\nbball_pivoted = bball.pivot_table(index="Year", columns="Player", values="Pts")\nbball_pivoted'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '`pivot_table` handles duplicate index/column pairs using an aggregation.\n\nBy default, the aggregation is the mean.\n\nFor example, our duplicated index/column pair is `("x", 1)` and had\nassociated values of 2 and 5.\n\nNotice that `bball_pivoted.loc[2016, "Ibaka"]` is `(15.1 + 14.2)/2 = 14.65`.\n\nWe can choose how `pandas` aggregates all of the values.\n\nFor example, here’s how we would keep the max.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'bball.pivot_table(index="Year", columns="Player", values="Pts", aggfunc=max)'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'Maybe we wanted to count how many values there were.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': 'bball'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball.pivot_table(index="Year", columns="Player", values="Pts", aggfunc=len)'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'We can even pass multiple aggregation functions!'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'bball.pivot_table(index="Year", columns="Player", values="Pts", aggfunc=[max, len])'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '**Exercise 3**\n\n- First, take a breath... That was a lot to take in.  \n- Can you think of a reason to ever use `pivot` rather than\n  `pivot_table`? Write your thoughts.  \n- Create a pivot table with column `Player` as the index, `TeamName` as the\n  columns, and `[Rebound, Assist]` as the values. What happens when you use\n  `aggfunc=[np.max, np.min, len]`? Describe how Python produced\n  each of the values in the resultant pivot table.  '}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': '-'}}, 'source': ''}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': ''}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'slide'}}, 'source': '## Visualizing Reshaping\n\nNow that you have learned the basics and had a chance to experiment,\nwe will use some generic data to provide a visualization of what the above\nreshape operations do.\n\nThe data we will use is:'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': '# made up\n# columns A and B are "identifiers" while C, D, and E are variables.\ndf = pd.DataFrame({\n    "A": [0, 0, 1, 1],\n    "B": "x y x z".split(),\n    "C": [1, 2, 1, 4],\n    "D": [10, 20, 30, 20,],\n    "E": [2, 1, 5, 4,]\n})\n\ndf.info()\ndf'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'df2 = df.set_index(["A", "B"])\ndf2.head()'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'df3 = df2.T\ndf3.head()'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### `stack` and `unstack`\n\nBelow is an animation that shows how stacking works.\n\n<img src="https://datascience.quantecon.org/_images/stack.gif" alt="stack.gif" style="">'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'df2'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'df2_stack = df2.stack()\ndf2_stack'}], [{'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': 'And here is an animation that shows how unstacking works.\n\n<img src="https://datascience.quantecon.org/_images/unstack_level0.gif" alt="unstack\\_level0.gif" style="">'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'df2'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'df2.unstack()'}, {'cell_type': 'markdown', 'metadata': {'slideshow': {'slide_type': 'subslide'}}, 'source': '### `melt`\n\nAs noted above, the `melt` method transforms data from wide to long in form.\n\nHere’s a visualization of that operation.\n\n<img src="https://datascience.quantecon.org/_images/melt.gif" alt="melt.gif" style="">'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}, 'outputs': [], 'source': 'df'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}, 'outputs': [], 'source': 'df_melted = df.melt(id_vars=["A", "B"])\ndf_melted'}]]