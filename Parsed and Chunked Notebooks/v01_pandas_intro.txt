[[{'cell_type': 'markdown', 'metadata': {}, 'source': '# Introduction\n\n**Prerequisites**\n\n- [Python Fundamentals](https://datascience.quantecon.org/python_fundamentals/index.html) (Summer pre course)\n\n**Outcomes**\n\n- Understand the core pandas objects (`Series` and `DataFrame`)  \n- Index into particular elements of a Series and DataFrame  \n- Understand what `.dtype`/`.dtypes` do  \n- Make basic visualizations  \n\n**Data**\n\n- US regional unemployment data from Bureau of Labor Statistics  \n\n'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': '1+1'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## Outline\n\n- [Introduction](#Introduction)  \n  - [pandas](#pandas)  \n  - [Series](#Series)  \n  - [DataFrame](#DataFrame)  \n  - [Data Types](#Data-Types)  \n  - [Changing DataFrames](#Changing-DataFrames)  \n  - [Exercises](#Exercises)  '}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# Uncomment following line to install on colab\n#! pip install qeds'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## pandas\n\nThis lecture begins the material on `pandas`.\n\nTo start, we will import the pandas package and give it the alias\n`pd`, which is conventional practice.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': "import pandas as pd\n\n# Don't worry about this line for now!\n%matplotlib inline\n# activate plot theme\nimport qeds\nqeds.themes.mpl_style();"}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'Sometimes, knowing which pandas version we are\nusing is helpful.\n\nWe can check this by running the code below.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'pd.__version__'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## Series\n\nThe first main pandas type we will introduce is called Series.\n\nA Series is a single column of data, with row labels for each\nobservation.\n\npandas refers to the row labels as the *index* of the Series.\n\n<img src="https://datascience.quantecon.org/assets/_static/intro_files/PandasSeries.png" alt="PandasSeries.png" style="">\n\n  \nBelow, we create a Series which contains the US unemployment rate every\nother year starting in 1995.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'values = [5.6, 5.3, 4.3, 4.2, 5.8, 5.3, 4.6, 7.8, 9.1, 8., 5.7]\nyears = list(range(1995, 2017, 2))\n\nunemp = pd.Series(data=values, index=years, name="Unemployment")'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'We can look at the index and values in our Series.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.index'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.values'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '### What Can We Do with a Series object?'}], [{'cell_type': 'markdown', 'metadata': {}, 'source': '#### `.head` and `.tail`\n\nOften, our data will have many rows, and we won’t want to display it all\nat once.\n\nThe methods `.head` and `.tail` show rows at the beginning and end\nof our Series, respectively.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.head()'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.tail()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### Basic Plotting\n\nWe can also plot data using the `.plot` method.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.plot()'}], [{'cell_type': 'markdown', 'metadata': {}, 'source': '>**Note**\n>\n>This is why we needed the `%matplotlib inline` — it tells the notebook\nto display figures inside the notebook itself. Also, pandas has much greater visualization functionality than this, but we will study that later on.'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### Unique Values\n\nThough it doesn’t make sense in this data set, we may want to find the\nunique values in a Series – which can be done with the `.unique` method.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.unique()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### Indexing\n\nSometimes, we will want to select particular elements from a Series.\n\nWe can do this using `.loc[index_items]`; where `index_items` is\nan item from the index, or a list of items in the index.\n\nWe will see this more in-depth in a coming lecture, but for now, we\ndemonstrate how to select one or multiple elements of the Series.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.loc[1995]'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.loc[[1995, 2005, 2015]]'}, {'cell_type': 'markdown', 'metadata': {}, 'source': "\n<a id='exercise-0'></a>\n> See exercise 1 in the [*exercise list*](#exerciselist-0)"}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## DataFrame\n\nA DataFrame is how pandas stores one or more columns of data.\n\nWe can think a DataFrames a multiple Series stacked side by side as\ncolumns.\n\nThis is similar to a sheet in an Excel workbook or a table in a SQL\ndatabase.\n\nIn addition to row labels (an index), DataFrames also have column labels.\n\nWe refer to these column labels as the columns or column names.\n\n<img src="https://datascience.quantecon.org/assets/_static/intro_files/PandasDataFrame.png" alt="PandasDataFrame.png" style="">\n\nBelow, we create a DataFrame that contains the unemployment rate every\nother year by region of the US starting in 1995.\n\n'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'data = {\n    "NorthEast": [5.9,  5.6,  4.4,  3.8,  5.8,  4.9,  4.3,  7.1,  8.3,  7.9,  5.7],\n    "MidWest": [4.5,  4.3,  3.6,  4. ,  5.7,  5.7,  4.9,  8.1,  8.7,  7.4,  5.1],\n    "South": [5.3,  5.2,  4.2,  4. ,  5.7,  5.2,  4.3,  7.6,  9.1,  7.4,  5.5],\n    "West": [6.6, 6., 5.2, 4.6, 6.5, 5.5, 4.5, 8.6, 10.7, 8.5, 6.1],\n    "National": [5.6, 5.3, 4.3, 4.2, 5.8, 5.3, 4.6, 7.8, 9.1, 8., 5.7]\n}\n\nunemp_region = pd.DataFrame(data, index=years)\nunemp_region'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'We can retrieve the index and the DataFrame values as we\ndid with a Series.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.index'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.values'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '### What Can We Do with a DataFrame?\n\nPretty much everything we can do with a Series.'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### `.head` and `.tail`\n\nAs with Series, we can use `.head` and `.tail` to show only the\nfirst or last `n` rows.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.head()'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.tail(3)'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### Plotting\n\nWe can generate plots with the `.plot` method.\n\nNotice we now have a separate line for each column of data.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.plot()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '#### Indexing\n\nWe can also do indexing using `.loc`.\n\nThis is slightly more advanced than before because we can choose\nsubsets of both row and columns.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.loc[1995, "NorthEast"]'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.loc[[1995, 2005], "South"]'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.loc[1995, ["NorthEast", "National"]]'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.loc[:, "NorthEast"]'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# `[string]` with no `.loc` extracts a whole column\nunemp_region["MidWest"]'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '### Computations with Columns\n\npandas can do various computations and mathematical operations on\ncolumns.\n\nLet’s take a look at a few of them.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# Divide by 100 to move from percent units to a rate\nunemp_region["West"] / 100'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# Find maximum\nunemp_region["West"].max()'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# Find the difference between two columns\n# Notice that pandas applies `-` to _all rows_ at once\n# We\'ll see more of this throughout these materials\nunemp_region["West"] - unemp_region["MidWest"]'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# Find correlation between two columns\nunemp_region.West.corr(unemp_region["MidWest"])'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': '# find correlation between all column pairs\nunemp_region.corr()'}], [{'cell_type': 'markdown', 'metadata': {}, 'source': "\n<a id='exercise-1'></a>\n> See exercise 2 in the [*exercise list*](#exerciselist-0)"}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## Data Types\n\nWe asked you to run the commands `unemp.dtype` and\n`unemp_region.dtypes` and think about the outputs.\n\nYou might have guessed that they return the type of the values inside\neach column.\n\nOccasionally, you might need to investigate what types you have in your\nDataFrame when an operation isn’t behaving as expected.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp.dtype'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.dtypes'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'DataFrames will only distinguish between a few types.\n\n- Booleans (`bool`)  \n- Floating point numbers (`float64`)  \n- Integers (`int64`)  \n- Dates (`datetime`) — we will learn this soon  \n- Categorical data (`categorical`)  \n- Everything else, including strings (`object`)  \n\n\nIn the future, we will often refer to the type of data stored in a\ncolumn as its `dtype`.\n\nLet’s look at an example for when having an incorrect `dtype` can\ncause problems.\n\nSuppose that when we imported the data the `South` column was\ninterpreted as a string.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'str_unemp = unemp_region.copy()\nstr_unemp["South"] = str_unemp["South"].astype(str)\nstr_unemp.dtypes'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'Everything *looks* ok…'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'str_unemp.head()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'But if we try to do something like compute the sum of all the columns,\nwe get unexpected results…'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'str_unemp.sum()'}], [{'cell_type': 'markdown', 'metadata': {}, 'source': 'This happened because `.sum` effectively calls `+` on all rows in\neach column.\n\nRecall that when we apply `+` to two strings, the result is the two\nstrings concatenated.\n\nSo, in this case, we saw that the entries in all rows of the South\ncolumn were stitched together into one long string.'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '## Changing DataFrames\n\nWe can change the data inside of a DataFrame in various ways:\n\n- Adding new columns  \n- Changing index labels or column names  \n- Altering existing data (e.g. doing some arithmetic or making a column\n  of strings lowercase)  \n\n\nSome of these “mutations” will be topics of future lectures, so we will\nonly briefly discuss a few of the things we can do below.'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '### Creating New Columns\n\nWe can create new data by assigning values to a column similar to how\nwe assign values to a variable.\n\nIn pandas, we create a new column of a DataFrame by writing:'}, {'cell_type': 'markdown', 'metadata': {'hide-output': False}, 'source': '```python\ndf["New Column Name"] = new_values\n```\n'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'Below, we create an unweighted mean of the unemployment rate across the\nfour regions of the US — notice that this differs from the national\nunemployment rate.'}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region["UnweightedMean"] = (unemp_region["NorthEast"] +\n                                  unemp_region["MidWest"] +\n                                  unemp_region["South"] +\n                                  unemp_region["West"])/4'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.head()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': '### Changing Values\n\nChanging the values inside of a DataFrame should be done sparingly.\n\nHowever, it can be done by assigning a value to a location in the\nDataFrame.\n\n`df.loc[index, column] = value`'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.loc[1995, "UnweightedMean"] = 0.0'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.head()'}], [{'cell_type': 'markdown', 'metadata': {}, 'source': '### Renaming Columns\n\nWe can also rename the columns of a DataFrame, which is helpful because the names that sometimes come with datasets are\nunbearable…\n\nFor example, the original name for the North East unemployment rate\ngiven by the Bureau of Labor Statistics was `LASRD910000000000003`…\n\nThey have their reasons for using these names, but it can make our job\ndifficult since we often need to type it repeatedly.\n\nWe can rename columns by passing a dictionary to the `rename` method.\n\nThis dictionary contains the old names as the keys and new names as the\nvalues.\n\nSee the example below.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'names = {"NorthEast": "NE",\n         "MidWest": "MW",\n         "South": "S",\n         "West": "W"}\nunemp_region.rename(columns=names)'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'unemp_region.head()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': 'We renamed our columns… Why does the DataFrame still show the old\ncolumn names?\n\nMany pandas operations create a copy of your data by\ndefault to protect your data and prevent you from overwriting\ninformation you meant to keep.\n\nWe can make these operations permanent by either:\n\n1. Assigning the output back to the variable name\n  `df = df.rename(columns=rename_dict)`  \n1. Looking into whether the method has an `inplace` option. For\n  example, `df.rename(columns=rename_dict, inplace=True)`  \n\n\nSetting `inplace=True` will sometimes make your code faster\n(e.g. if you have a very large DataFrame and you don’t want to copy all\nthe data), but that doesn’t always happen.\n\nWe recommend using the first option until you get comfortable with\npandas because operations that don’t alter your data are (usually)\nsafer.'}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': ''}], [{'cell_type': 'code', 'execution_count': None, 'metadata': {'hide-output': False}, 'outputs': [], 'source': 'names = {"NorthEast": "NE",\n         "MidWest": "MW",\n         "South": "S",\n         "West": "W"}\n\nunemp_shortname = unemp_region.rename(columns=names)\nunemp_shortname.head()'}, {'cell_type': 'markdown', 'metadata': {}, 'source': "## Exercises\n\n\n<a id='exerciselist-0'></a>\n**Exercise 1**\n\nFor each of the following exercises, we recommend reading the documentation\nfor help.\n\n- Display only the first 2 elements of the Series using the `.head` method.  \n- Using the `plot` method, make a bar plot.  \n- Use `.loc` to select the lowest/highest unemployment rate shown in the Series.  \n- Run the code `unemp.dtype` below. What does it give you? Where do you think it comes from?  \n\n\n([*back to text*](#exercise-0))\n\n**Exercise 2**\n\nFor each of the following, we recommend reading the documentation for help.\n\n- Use introspection (or google-fu) to find a way to obtain a list with\n  all of the column names in `unemp_region`.  \n- Using the `plot` method, make a bar plot. What does it look like\n  now?  \n- Use `.loc` to select the the unemployment data for the\n  `NorthEast` and `West` for the years 1995, 2005, 2011, and 2015.  \n- Run the code `unemp_region.dtypes` below. What does it give you?\n  How does this compare with `unemp.dtype`?  \n\n\n([*back to text*](#exercise-1))"}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': ''}, {'cell_type': 'code', 'execution_count': None, 'metadata': {}, 'outputs': [], 'source': ''}]]