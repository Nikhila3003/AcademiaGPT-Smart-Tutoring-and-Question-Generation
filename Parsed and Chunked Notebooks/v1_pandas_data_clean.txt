[[{'cell_type': 'markdown', 'source': '# Cleaning Data\n\n**Prerequisites**\n\n- [Intro](../p01_pandas_intro/v01_pandas_intro.ipynb)  \n- [Boolean selection](../p01_pandas_intro/v02_pandas_basics.ipynb)  \n- [Indexing](../p02_organizing_data_with_pandas_1/01_the_index.ipynb)  \n\n\n**Outcomes**\n\n- Be able to use string methods to clean data that comes as a string  \n- Be able to drop missing data  \n- Use cleaning methods to prepare and analyze a real dataset  \n\n\n**Data**\n\n- Item information from about 3,000 Chipotle meals from about 1,800\n  Grubhub orders  ', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'import pandas as pd\nimport numpy as np', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': '## Outline\n\n- [Cleaning Data](#Cleaning-Data)  \n  - [Cleaning Data](#Cleaning-Data)  \n  - [String Methods](#String-Methods)  \n  - [Type Conversions](#Type-Conversions)  \n  - [Missing Data](#Missing-Data)  \n  - [Case Study](#Case-Study)  \n  - [Appendix: Performance of `.str` Methods](#Appendix:-Performance-of-`.str`-Methods)  ', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'markdown', 'source': '## Cleaning Data\n\nFor many data projects, a [significant proportion of\ntime](https://www.forbes.com/sites/gilpress/2016/03/23/data-preparation-most-time-consuming-least-enjoyable-data-science-task-survey-says/#74d447456f63)\nis spent collecting and cleaning the data — not performing the analysis.\n\nThis non-analysis work is often called “data cleaning”.\n\npandas provides very powerful data cleaning tools, which we\nwill demonstrate using the following dataset.', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df = pd.DataFrame({"numbers": ["#23", "#24", "#18", "#14", "#12", "#10", "#35"],\n                   "nums": ["23", "24", "18", "14", np.nan, "XYZ", "35"],\n                   "colors": ["green", "red", "yellow", "orange", "purple", "blue", "pink"],\n                   "other_column": [0, 1, 0, 2, 1, 0, 2]})\ndf\n', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'subslide'}}}], [{'cell_type': 'markdown', 'source': 'What would happen if we wanted to try and compute the mean of\n`numbers`?', 'metadata': {'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df["numbers"].mean()\n', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}}, {'cell_type': 'markdown', 'source': 'It throws an error!\n\nCan you figure out why?\n\nHint: When looking at error messages, start at the very\nbottom.\n\nThe final error says, `TypeError: Could not convert #23#24... to numeric`.\n', 'metadata': {'slideshow': {'slide_type': 'fragment'}}}, {'cell_type': 'markdown', 'source': "The problem is that if we look at the `dtypes` of the DataFrame that the elements of the `numbers` column are strings!\n\nWe learned how to modify strings in one of the lectures about Python fundamentals. Let's modify one of the strings contained in the `numbers` column as a reminder:", 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'numbers_str = "#35"\n\nnumbers_num = int(numbers_str.replace("#", ""))\n\nprint(numbers_str)\nprint(numbers_num)\nprint(type(numbers_num))', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'markdown', 'source': '## String Methods\n\nOur solution to the previous exercise was to remove the `#` by using\nthe `replace` string method: `int(numbers_str.replace("#", ""))`.\n\nOne way to make this change to every element of a column would be to\nloop through all elements of the column and apply the desired string\nmethods…', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '%%time\n\n# Iterate over all rows\nfor row in df.iterrows():\n\n    # `iterrows` method produces a tuple with two elements...\n    # The first element is an index and the second is a Series with the data from that row\n    index_value, column_values = row\n\n    # Apply string method\n    clean_number = int(column_values["numbers"].replace("#", ""))\n\n    # The `at` method is very similar to the `loc` method, but it is specialized\n    # for accessing single elements at a time... We wanted to use it here to give\n    # the loop the best chance to beat a faster method which we show you next.\n    df.at[index_value, "numbers_loop"] = clean_number', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'While this is fast for a small dataset like this, this method slows for larger datasets.\n\nOne *significantly* faster (and easier) method is to apply a string\nmethod to an entire column of data.\n\nMost methods that are available to a Python string (we learned a\nfew of them in the [strings lecture](../python_fundamentals/basics.ipynb)) are\nalso available to a pandas Series that has `dtype` object.\n\nWe access them by doing `s.str.method_name` where `method_name` is\nthe name of the method.\n\nWhen we apply the method to a Series, it is applied to all rows in the\nSeries in one shot!\n\nLet’s redo our previous example using a pandas `.str` method.', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '%%time\n\n# ~2x faster than loop... However, speed gain increases with size of DataFrame. The\n# speedup can be in the ballpark of ~100-500x faster for big DataFrames.\n# See appendix at the end of the lecture for an application on a larger DataFrame\ndf["numbers_str"] = df["numbers"].str.replace("#", "")\n\ndf.dtypes', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'We can use `.str` to access almost any string method that works on\nnormal strings. (See the [official\ndocumentation](https://pandas.pydata.org/pandas-docs/stable/text.html)\nfor more information.)', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}], [{'cell_type': 'code', 'execution_count': None, 'source': 'df["colors"].str.contains("p")', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df["colors"].str.capitalize()', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': '## Type Conversions\n\nIn our example above, the `dtype` of the `numbers_str` column shows that pandas still treats\nit as a string even after we have removed the `"#"`.\n\nWe need to convert this column to numbers.\n\nThe best way to do this is using the `pd.to_numeric` function.\n\nThis method attempts to convert whatever is stored in a Series into\nnumeric values\n\nFor example, after the `"#"` removed, the numbers of column\n`"numbers"` are ready to be converted to actual numbers.', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df["numbers_numeric"] = pd.to_numeric(df["numbers_str"])', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df.dtypes', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}}], [{'cell_type': 'code', 'execution_count': None, 'source': 'df.head()', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'fragment'}}}, {'cell_type': 'markdown', 'source': 'We can convert to other types well.\n\nUsing the `astype` method, we can convert to any of the supported\npandas `dtypes` (recall the [intro lecture](intro.ipynb)).\n\nBelow are some examples. (Pay attention to the reported `dtype`)', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df["numbers_numeric"].astype(str)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df["numbers_numeric"].astype(float)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': '## Missing Data\n\nMany datasets have missing data.\n\nIn our example, we are missing an element from the `"nums"` column.', 'metadata': {'slideshow': {'slide_type': 'slide'}}}], [{'cell_type': 'code', 'execution_count': None, 'source': 'df', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'We can find missing data by using the `isnull` method.', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df.isnull()', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'We might want to know whether particular rows or columns have any\nmissing data.\n\nTo do this we can use the `.any` method on the boolean DataFrame\n`df.isnull()`.', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'df.isnull().any(axis=0)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'code', 'execution_count': None, 'source': 'df.isnull().any(axis=1)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'Many approaches have been developed to deal with missing data, but the two most commonly used (and the corresponding DataFrame method) are:\n\n- Exclusion: Ignore any data that is missing (`.dropna`).  \n- Imputation: Compute “predicted” values for the data that is missing\n  (`.fillna`).  \n\n\nFor the advantages and disadvantages of these (and other) approaches,\nconsider reading the [Wikipedia\narticle](https://en.wikipedia.org/wiki/Missing_data).\n\nFor now, let’s see some examples.', 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '# drop all rows containing a missing observation\ndf.dropna(axis=1)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '# fill the missing values with a specific value\ndf.fillna(value=100)', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '# use the _next_ valid observation to fill the missing data\ndf.fillna(method="bfill")', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'code', 'execution_count': None, 'source': '# use the _previous_ valid observation to fill missing data\ndf.fillna(method="ffill")', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': 'We will see more examples of dealing with missing data in future\nchapters.', 'metadata': {'slideshow': {'slide_type': '-'}}}, {'cell_type': 'markdown', 'source': '## Case Study\n\nWe will now use data from an\n[article](https://www.nytimes.com/interactive/2015/02/17/upshot/what-do-people-actually-order-at-chipotle.html)\nwritten by The Upshot at the NYTimes.\n\nThis data has order information from almost 2,000 Chipotle orders and\nincludes information on what was ordered and how much it cost.', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'url = "https://datascience.quantecon.org/assets/data/chipotle_raw.csv.zip"\nchipotle = pd.read_csv(url)\nchipotle.head()', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'chipotle.head()', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'markdown', 'source': "**Exercise**\n\nWe'd like you to use this data to answer the following questions.\n\n- What is the average price of an item with chicken?  \n- What is the average price of an item with steak?  \n- Did chicken or steak produce more revenue (total)?  \n- How many missing items are there in this dataset? How many missing\n  items in each column?  \n\n\nHint: before you will be able to do any of these things you will need to\nmake sure the `item_price` column has a numeric `dtype` (probably\nfloat)\n", 'metadata': {'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '', 'outputs': [], 'metadata': {'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'markdown', 'source': '## Appendix: Performance of `.str` Methods\n\nLet’s repeat the “remove the `#`” example from above, but this time on\na much larger dataset.', 'metadata': {'slideshow': {'slide_type': 'slide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'import numpy as np\ntest = pd.DataFrame({"floats": np.round(100*np.random.rand(100_000), 2)})\ntest["strings"] = test["floats"].astype(str) + "%"\ntest.head()', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '%%time\n\nfor row in test.iterrows():\n    index_value, column_values = row\n    clean_number = column_values["strings"].replace("%", "")\n    test.at[index_value, "numbers_loop"] = clean_number', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': 'subslide'}}}, {'cell_type': 'code', 'execution_count': None, 'source': '%%time\ntest["numbers_str_method"] = test["strings"].str.replace("%", "")', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}, {'cell_type': 'code', 'execution_count': None, 'source': 'test["numbers_str_method"].equals(test["numbers_loop"])', 'outputs': [], 'metadata': {'hide-output': False, 'slideshow': {'slide_type': '-'}}}], [{'cell_type': 'markdown', 'source': 'We got the exact same result in a fraction of the time!', 'metadata': {'slideshow': {'slide_type': '-'}}}]]